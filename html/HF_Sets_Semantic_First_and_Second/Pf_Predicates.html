<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Pf_Predicates (Isabelle2020-RC3: March 2020)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Pf_Predicates</h1>

<span class="command">theory</span> <span class="name">Pf_Predicates</span><br/>
<span class="keyword">imports</span> <a href="Coding_Predicates.html"><span class="name">Coding_Predicates</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">chapter</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Formalizing Provability&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Pf_Predicates</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Coding_Predicates</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Section 4 Predicates (Leading up to Pf)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The predicate &#8249;SentP&#8250;, for the Sentiential (Boolean) Axioms&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Sent_axioms</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hf &#8658; hf &#8658; hf &#8658; hf &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Sent_axioms x y z w &#8801;
             x = q_Imp y y &#8744;
             x = q_Imp y (q_Disj y z) &#8744;
             x = q_Imp (q_Disj y y) y &#8744;
             x = q_Imp (q_Disj y (q_Disj z w)) (q_Disj (q_Disj y z) w) &#8744;
             x = q_Imp (q_Disj y z) (q_Imp (q_Disj (q_Neg y) w) (q_Disj z w))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Sent</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hf set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Sent &#8801; {x. &#8707;y z w. Form y &#8743; Form z &#8743; Form w &#8743; Sent_axioms x y z w}&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>SentP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom y &#9839; (z,w,x); atom z &#9839; (w,x); atom w &#9839; x&#10215; &#10233;
    SentP x = Ex y (Ex z (Ex w (FormP (Var y) AND FormP (Var z) AND FormP (Var w) AND
               ( (x EQ Q_Imp (Var y) (Var y)) OR
                 (x EQ Q_Imp (Var y) (Q_Disj (Var y) (Var z)) OR
                 (x EQ Q_Imp (Q_Disj (Var y) (Var y)) (Var y)) OR
                 (x EQ Q_Imp (Q_Disj (Var y) (Q_Disj (Var z) (Var w))) 
                             (Q_Disj (Q_Disj (Var y) (Var z)) (Var w))) OR
                 (x EQ Q_Imp (Q_Disj (Var y) (Var z))
                             (Q_Imp (Q_Disj (Q_Neg (Var y)) (Var w)) (Q_Disj (Var z) (Var w)))))))))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>SentP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>SentP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; SentP x &#10231; a &#9839; x&quot;</span></span></span><span>                  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eval_fm_SentP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;eval_fm e (SentP x) &#10231; &#10214;x&#10215;e &#8712; Sent&quot;</span></span></span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis2</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SentP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (SentP x)&quot;</span></span></span><span>                     </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thsf</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>y</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>z</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>w</span><span class="delimiter">::</span><span>name</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom y &#9839; (z,w,x)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom z &#9839; (w,x)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom w &#9839; x&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thesis2</span><span> </span><span class="var">?thsf</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Sent_def</span><span> </span><span>Sent_axioms_def</span><span> </span><span>q_defs</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The predicate &#8249;Equality_axP&#8250;, for the Equality Axioms&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Equality_ax</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hf set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Equality_ax &#8801; { &#10214;&#171;refl_ax&#187;&#10215;e0, &#10214;&#171;eq_cong_ax&#187;&#10215;e0, &#10214;&#171;mem_cong_ax&#187;&#10215;e0, &#10214;&#171;eats_cong_ax&#187;&#10215;e0 }&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">function</span></span><span> </span><span>Equality_axP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Equality_axP x =
    x EQ &#171;refl_ax&#187; OR x EQ &#171;eq_cong_ax&#187; OR x EQ &#171;mem_cong_ax&#187; OR x EQ &#171;eats_cong_ax&#187;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">termination</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eval_fm_Equality_axP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;eval_fm e (Equality_axP x) &#10231; &#10214;x&#10215;e &#8712; Equality_ax&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Equality_ax_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>eval_quot_fm_ignore</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The predicate &#8249;HF_axP&#8250;, for the HF Axioms&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>HF_ax</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hf set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;HF_ax &#8801; {&#10214;&#171;HF1&#187;&#10215;e0, &#10214;&#171;HF2&#187;&#10215;e0}&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">function</span></span><span> </span><span>HF_axP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;HF_axP x = x EQ &#171;HF1&#187; OR x EQ &#171;HF2&#187;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">termination</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eval_fm_HF_axP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;eval_fm e (HF_axP x) &#10231; &#10214;x&#10215;e &#8712; HF_ax&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>HF_ax_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>eval_quot_fm_ignore</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HF_axP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (HF_axP t)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The specialisation axioms&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_set</span></span><span> </span><span>Special_ax</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hf set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;AbstForm v 0 x ax; SubstForm v y x sx; Form x; is_Var v; Term y&#10215;
      &#10233; q_Imp sx (q_Ex ax) &#8712; Special_ax&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Defining the syntax&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>Special_axP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; fm&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom v &#9839; (p,sx,y,ax,x); atom x &#9839; (p,sx,y,ax);
    atom ax &#9839; (p,sx,y); atom y &#9839; (p,sx); atom sx &#9839; p&#10215; &#10233;
  Special_axP p = Ex v (Ex x (Ex ax (Ex y (Ex sx
                   (FormP (Var x) AND VarP (Var v) AND TermP (Var y) AND
                    AbstFormP (Var v) Zero (Var x) (Var ax) AND
                    SubstFormP (Var v) (Var y) (Var x) (Var sx) AND
                    p EQ Q_Imp (Var sx) (Q_Ex (Var ax)))))))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>Special_axP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>Special_axP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; Special_axP p &#10231; a &#9839; p&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eval_fm_Special_axP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;eval_fm e (Special_axP p) &#10231; &#10214;p&#10215;e &#8712; Special_ax&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis2</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Special_axP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (Special_axP p)&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis3</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>v</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ax</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sx</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom v &#9839; (p,sx,y,ax,x)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom x &#9839; (p,sx,y,ax)&quot;</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;atom ax &#9839; (p,sx,y)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom y &#9839; (p,sx)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom sx &#9839; p&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thesis2</span><span> </span><span class="var">?thesis3</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>q_Disj_def</span><span> </span><span>q_Ex_def</span><span> </span><span>q_Imp_def</span><span> </span><span>q_Neg_def</span><span> </span><span>Special_ax.intros</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>q_Disj_def</span><span> </span><span>q_Ex_def</span><span> </span><span>q_Imp_def</span><span> </span><span>q_Neg_def</span><span> </span><span>Special_ax.cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Correctness (or, correspondence)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Special_ax_imp_special_axioms</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; Special_ax&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;A. x = &#10214;&#171;A&#187;&#10215;e &#8743; A &#8712; special_axioms&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>Special_ax.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>I</span><span> </span><span>v</span><span> </span><span>x</span><span> </span><span>ax</span><span> </span><span>y</span><span> </span><span>sx</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>fm</span><span class="delimiter">::</span><span>fm</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>u</span><span class="delimiter">::</span><span>tm</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>fm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x = &#10214;&#171;fm&#187;&#10215;e&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y = &#10214;&#171;u&#187;&#10215;e&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>I</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>Form_imp_is_fm</span><span> </span><span>Term_imp_is_tm</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>B</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x  = &#10214;quot_dbfm B&#10215;e&quot;</span></span></span><span>
</span><span>            </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ax</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ax = &#10214;quot_dbfm (abst_dbfm (decode_Var v) 0 B)&#10215;e&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>I</span><span> </span><span>AbstForm_imp_abst_dbfm</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>B&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x = &#10214;quot_dbfm B&#39;&#10215;e&quot;</span></span></span><span>
</span><span>             </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sx</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sx = &#10214;quot_dbfm (subst_dbfm (trans_tm [] u) (decode_Var v) B&#39;)&#10215;e&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>I</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>u</span><span> </span><span>SubstForm_imp_subst_dbfm_lemma</span><span> </span><span>quot_tm_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;B&#39;=B&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>quot_dbfm_inject_lemma</span><span> </span><span>x</span><span> </span><span>x&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fm(decode_Var v::=u) IMP SyntaxN.Ex (decode_Var v) fm &#8712; special_axioms&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>special_axioms.intros</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eq</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>quot_simps</span><span> </span><span>q_defs</span><span> 
</span><span>                </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fm((decode_Var v)::=u) IMP (Ex (decode_Var v) fm)&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fm</span><span> </span><span>quot_dbfm_inject_lemma</span><span> </span><span>quot_fm_def</span><span> </span><span>subst_fm_trans_commute</span><span> </span><span>sx</span><span> </span><span>x&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>abst_trans_fm</span><span> </span><span>ax</span><span> </span><span>fm</span><span> </span><span>quot_dbfm_inject_lemma</span><span> </span><span>quot_fm_def</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>special_axioms_into_Special_ax</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A &#8712; special_axioms &#10233; &#10214;&#171;A&#187;&#10215;e &#8712; Special_ax&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>special_axioms.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>I</span><span> </span><span>A</span><span> </span><span>i</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#171;A(i::=t) IMP SyntaxN.Ex i A&#187;&#10215;e =
        q_Imp &#10214;quot_dbfm (subst_dbfm (trans_tm [] t) i (trans_fm [] A))&#10215;e
              (q_Ex &#10214;quot_dbfm (trans_fm [i] A)&#10215;e)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>quot_fm_def</span><span> </span><span>q_defs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;... &#8712; Special_ax&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Special_ax.intros</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>AbstForm_trans_fm</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>quot_fm_def</span><span> </span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>SubstForm_quot</span><span> </span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>eval_Var_q</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;We have precisely captured the codes of the specialisation axioms.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>Special_ax_eq_special_axioms</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Special_ax = (&#8899;A &#8712; special_axioms. { &#10214;&#171;A&#187;&#10215;e })&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>special_axioms_into_Special_ax</span><span> </span><span>Special_ax_imp_special_axioms</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The induction axioms&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_set</span></span><span> </span><span>Induction_ax</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hf set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;SubstForm v 0 x x0;
       SubstForm v w x xw;
       SubstForm v (q_Eats v w) x xevw;
       AbstForm w 0 (q_Imp x (q_Imp xw xevw)) allw;
       AbstForm v 0 (q_All allw) allvw;
       AbstForm v 0 x ax;
       v &#8800; w; VarNonOccForm w x&#10215;
      &#10233; q_Imp x0 (q_Imp (q_All allvw) (q_All ax)) &#8712; Induction_ax&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Defining the syntax&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>Induction_axP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; fm&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom ax &#9839; (p,v,w,x,x0,xw,xevw,allw,allvw);
    atom allvw &#9839; (p,v,w,x,x0,xw,xevw,allw); atom allw &#9839; (p,v,w,x,x0,xw,xevw);
    atom xevw &#9839; (p,v,w,x,x0,xw); atom xw &#9839; (p,v,w,x,x0);
    atom x0 &#9839; (p,v,w,x); atom x &#9839; (p,v,w);
    atom w &#9839; (p,v); atom v &#9839; p&#10215; &#10233;
  Induction_axP p = Ex v (Ex w (Ex x (Ex x0 (Ex xw (Ex xevw (Ex allw (Ex allvw (Ex ax
               ((Var v NEQ Var w) AND VarNonOccFormP (Var w) (Var x) AND
                SubstFormP (Var v) Zero (Var x) (Var x0) AND
                SubstFormP (Var v) (Var w) (Var x) (Var xw) AND
                SubstFormP (Var v) (Q_Eats (Var v) (Var w)) (Var x) (Var xevw) AND
                AbstFormP (Var w) Zero (Q_Imp (Var x) (Q_Imp (Var xw) (Var xevw))) (Var allw) AND
                AbstFormP (Var v) Zero (Q_All (Var allw)) (Var allvw) AND
                AbstFormP (Var v) Zero (Var x) (Var ax) AND
                p EQ Q_Imp (Var x0) (Q_Imp (Q_All (Var allvw)) (Q_All (Var ax))))))))))))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>Induction_axP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>Induction_axP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; Induction_axP p &#10231; a &#9839; p&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eval_fm_Induction_axP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;eval_fm e (Induction_axP p) &#10231; &#10214;p&#10215;e &#8712; Induction_ax&quot;</span></span></span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis2</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Induction_axP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (Induction_axP p)&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis3</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>v</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>w</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x0</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xw</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xevw</span><span class="delimiter">::</span><span>name</span><span>
</span><span>                 </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>allw</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>allvw</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ax</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>atoms</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom ax &#9839; (p,v,w,x,x0,xw,xevw,allw,allvw)&quot;</span></span></span><span>
</span><span>                 </span><span class="string"><span class="delete"><span class="delete">&quot;atom allvw &#9839; (p,v,w,x,x0,xw,xevw,allw)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom allw &#9839; (p,v,w,x,x0,xw,xevw)&quot;</span></span></span><span>
</span><span>                 </span><span class="string"><span class="delete"><span class="delete">&quot;atom xevw &#9839; (p,v,w,x,x0,xw)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom xw &#9839; (p,v,w,x,x0)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom x0 &#9839; (p,v,w,x)&quot;</span></span></span><span>
</span><span>                 </span><span class="string"><span class="delete"><span class="delete">&quot;atom x &#9839; (p,v,w)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom w &#9839; (p,v)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom v &#9839; p&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thesis3</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis2</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;eval_fm e (Induction_axP p)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;p&#10215;e &#8712; Induction_ax&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>atoms</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>Induction_ax.I</span><span> </span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>q_defs</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;p&#10215;e &#8712; Induction_ax&quot;</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;eval_fm e (Induction_axP p)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Induction_ax.cases</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>atoms</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>q_defs</span><span> </span><span>htuple_minus_1</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>AbstForm_imp_Ord</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Correctness (or, correspondence)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Induction_ax_imp_induction_axioms</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; Induction_ax&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;A. x = &#10214;&#171;A&#187;&#10215;e &#8743; A &#8712; induction_axioms&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>Induction_ax.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>I</span><span> </span><span>v</span><span> </span><span>x</span><span> </span><span>x0</span><span> </span><span>w</span><span> </span><span>xw</span><span> </span><span>xevw</span><span> </span><span>allw</span><span> </span><span>allvw</span><span> </span><span>ax</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>v</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Var v&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>w</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Var w&quot;</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dvw</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;decode_Var v &#8800; decode_Var w&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;atom (decode_Var w) &#9839; [decode_Var v]&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>AbstForm_def</span><span> </span><span>fresh_Cons</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>A</span><span class="delimiter">::</span><span>fm</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x = &#10214;&#171;A&#187;&#10215;e&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>wfresh</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom (decode_Var w) &#9839; A&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>I</span><span> </span><span>VarNonOccForm_imp_fresh</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>A&#39;</span><span> </span><span>A&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q_Imp (&#10214;&#171;A&#187;&#10215;e) (q_Imp xw xevw) = &#10214;quot_dbfm A&#39;&#10215;e&quot;</span></span></span><span>
</span><span>                       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>A&#39;&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q_All allw = &#10214;quot_dbfm A&#39;&#39;&#10215;e&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>I</span><span> </span><span>VarNonOccForm_imp_fresh</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>AbstForm_imp_abst_dbfm</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>Aw</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Aw = A(decode_Var v::=Var (decode_Var w))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>Ae</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Ae = A(decode_Var v::= Eats (Var (decode_Var v)) (Var (decode_Var w)))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x0 = &#10214;&#171;A(decode_Var v::=Zero)&#187;&#10215;e&quot;</span></span></span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>I</span><span> </span><span>SubstForm_imp_subst_fm</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>A</span><span> </span><span>Form_quot_fm</span><span> </span><span>eval_fm_inject</span><span> </span><span>eval_tm.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>quot_Zero</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xw</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xw = &#10214;&#171;Aw&#187;&#10215;e&quot;</span></span></span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>I</span><span> </span><span>SubstForm_imp_subst_fm</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>A</span><span> </span><span>Form_quot_fm</span><span> </span><span>eval_fm_inject</span><span> </span><span>is_Var_imp_decode_Var</span><span> </span><span>w</span><span> </span><span>Aw_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SubstForm v (&#10214;&#171;Eats (Var (decode_Var v)) (Var (decode_Var w))&#187;&#10215;e) x xevw&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>I</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>quot_simps</span><span> </span><span>q_defs</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>is_Var_iff</span><span> </span><span>v</span><span> </span><span>w</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>xevw</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xevw = &#10214;&#171;Ae&#187;&#10215;e&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>A</span><span> </span><span>Ae_def</span><span> </span><span>Form_quot_fm</span><span> </span><span>SubstForm_imp_subst_fm</span><span> </span><span>eval_fm_inject</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ax</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ax = &#10214;quot_dbfm (abst_dbfm (decode_Var v) 0 (trans_fm [] A))&#10215;e&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>I</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>A</span><span> </span><span>AbstForm_imp_abst_dbfm</span><span> </span><span>nat_of_ord_0</span><span> </span><span>quot_dbfm_inject_lemma</span><span> </span><span>quot_fm_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>evw</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q_Imp x (q_Imp xw xevw) =
             &#10214;quot_dbfm (trans_fm [] (A IMP (Aw IMP Ae)))&#10215;e&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A</span><span> </span><span>xw</span><span> </span><span>xevw</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>quot_simps</span><span> </span><span>q_defs</span><span> </span><span>quot_fm_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>allw</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;allw = &#10214;quot_dbfm (abst_dbfm (decode_Var w) 0
                                    (trans_fm [] (A IMP (Aw IMP Ae))))&#10215;e&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>I</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>AbstForm_imp_abst_dbfm</span><span> </span><span>nat_of_ord_0</span><span> </span><span>quot_dbfm_inject_lemma</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>evw</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q_All allw = &#10214;quot_dbfm (trans_fm [] (All (decode_Var w) (A IMP (Aw IMP Ae))))&#10215;e&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>q_defs</span><span> </span><span>abst_trans_fm</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>allvw</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;allvw = &#10214;quot_dbfm (abst_dbfm (decode_Var v) 0
                                     (trans_fm [] (All (decode_Var w) (A IMP (Aw IMP Ae)))))&#10215;e&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>I</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>AbstForm_imp_abst_dbfm</span><span> </span><span>nat_of_ord_0</span><span> </span><span>quot_dbfm_inject_lemma</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>ind_ax</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ind_ax =
        A(decode_Var v::=Zero) IMP
        ((All (decode_Var v) (All (decode_Var w) (A IMP (Aw IMP Ae)))) IMP
        (All (decode_Var v) A))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom (decode_Var w) &#9839; (decode_Var v, A)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>I</span><span> </span><span>wfresh</span><span> </span><span>v</span><span> </span><span>w</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>atom_eq_iff</span><span> </span><span>decode_Var_inject</span><span> </span><span>fresh_Pair</span><span> </span><span>fresh_ineq_at_base</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ind_ax &#8712; induction_axioms&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ind_ax_def</span><span> </span><span>Aw_def</span><span> </span><span>Ae_def</span><span> </span><span>induction_axioms.intros</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>quot_simps</span><span> </span><span>q_defs</span><span> </span><span>ind_ax_def</span><span> </span><span>allvw</span><span> </span><span>ax</span><span> </span><span>x0</span><span> </span><span>abst_trans_fm2</span><span> </span><span>abst_trans_fm</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>induction_axioms_into_Induction_ax</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;A &#8712; induction_axioms &#10233; &#10214;&#171;A&#187;&#10215;e &#8712; Induction_ax&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>induction_axioms.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>ind</span><span> </span><span>j</span><span> </span><span>i</span><span> </span><span>A</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#171;A(i::=Zero) IMP All i (All j (A IMP A(i::=Var j) IMP A(i::=Eats (Var i) (Var j)))) IMP All i A&#187;&#10215;e =
            q_Imp &#10214;quot_dbfm (subst_dbfm (trans_tm [] Zero) i (trans_fm [] A))&#10215;e
            (q_Imp (q_All (q_All
                  (q_Imp &#10214;quot_dbfm (trans_fm [j, i] A)&#10215;e
                    (q_Imp
                      &#10214;quot_dbfm (trans_fm [j, i] (A(i::=Var j)))&#10215;e
                      &#10214;quot_dbfm (trans_fm [j, i] (A(i::=Eats (Var i) (Var j))))&#10215;e))))
              (q_All &#10214;quot_dbfm (trans_fm [i] A)&#10215;e))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>quot_simps</span><span> </span><span>q_defs</span><span> </span><span>quot_subst_eq</span><span> </span><span>fresh_Cons</span><span> </span><span>fresh_Pair</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom j &#9839; [i]&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ind</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fresh_Cons</span><span> </span><span>fresh_Nil</span><span> </span><span>fresh_Pair</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>eq</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>Induction_ax.intros</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>v</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q_Var i&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>w</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q_Var j&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SubstForm (q_Var i) 0 &#10214;&#171;A&#187;&#10215;e
           &#10214;quot_dbfm (subst_dbfm (trans_tm [] Zero) i (trans_fm [] A))&#10215;e&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>SubstForm_subst_dbfm_eq</span><span> </span><span>Term_quot_tm</span><span> </span><span>eval_tm.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>quot_Zero</span><span> </span><span>quot_fm_def</span><span> </span><span>quot_tm_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SubstForm (q_Var i) (q_Var j) &#10214;&#171;A&#187;&#10215;e &#10214;quot_dbfm (subst_dbfm (DBVar j) i (trans_fm [] A))&#10215;e&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>quot_fm_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>SubstForm_subst_dbfm_eq</span><span> </span><span>Term_Var</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="delimiter">(</span><span>metis</span><span> </span><span>q_Var_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SubstForm (q_Var i) (q_Eats (q_Var i) (q_Var j)) &#10214;&#171;A&#187;&#10215;e
              &#10214;quot_dbfm (subst_dbfm (DBEats (DBVar i) (DBVar j)) i (trans_fm [] A))&#10215;e&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>quot_fm_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>SubstForm_subst_dbfm_eq</span><span> </span><span>Term_Eats</span><span> </span><span>Term_Var</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>q_defs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;AbstForm (q_Var j) 0
           (q_Imp &#10214;&#171;A&#187;&#10215;e
              (q_Imp &#10214;quot_dbfm (subst_dbfm (DBVar j) i (trans_fm [] A))&#10215;e
                     &#10214;quot_dbfm (subst_dbfm (DBEats (DBVar i) (DBVar j)) i (trans_fm [] A))&#10215;e))
           &#10214;quot_dbfm (trans_fm [j] (A IMP (A(i::= Var j) IMP A(i::= Eats(Var i)(Var j)))))&#10215;e&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>AbstForm_trans_fm_eq</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(A IMP A(i::= Var j) IMP A(i::= Eats(Var i)(Var j)))&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>quot_simps</span><span> </span><span>q_defs</span><span> </span><span>quot_fm_def</span><span> </span><span>subst_fm_trans_commute_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;AbstForm (q_Var i) 0
     (q_All &#10214;quot_dbfm (trans_fm [j] (A IMP A(i::=Var j) IMP A(i::=Eats (Var i) (Var j))))&#10215;e)
     (q_All
       (q_Imp &#10214;quot_dbfm (trans_fm [j, i] A)&#10215;e
         (q_Imp &#10214;quot_dbfm (trans_fm [j, i] (A(i::=Var j)))&#10215;e
                &#10214;quot_dbfm (trans_fm [j, i] (A(i::=Eats (Var i) (Var j))))&#10215;e)))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>AbstForm_trans_fm_eq</span><span>
</span><span>               </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;All j (A IMP (A(i::= Var j) IMP A(i::= Eats(Var i)(Var j))))&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>q_defs</span><span> </span><span>quot_fm_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;AbstForm (q_Var i) 0 (&#10214;&#171;A&#187;&#10215;e) &#10214;quot_dbfm (trans_fm [i] A)&#10215;e&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>AbstForm_trans_fm</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q_Var i &#8800; q_Var j&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ind</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>q_Var_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;VarNonOccForm (q_Var j) (&#10214;&#171;A&#187;&#10215;e)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fresh_Pair</span><span> </span><span>fresh_imp_VarNonOccForm</span><span> </span><span>ind</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;We have captured the codes of the induction axioms.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>Induction_ax_eq_induction_axioms</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;Induction_ax = (&#8899;A &#8712; induction_axioms. {&#10214;&#171;A&#187;&#10215;e})&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>induction_axioms_into_Induction_ax</span><span> </span><span>Induction_ax_imp_induction_axioms</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The predicate &#8249;AxiomP&#8250;, for any Axioms&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Extra_ax</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hf set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Extra_ax &#8801; {&#10214;&#171;extra_axiom&#187;&#10215;e0}&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Axiom</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hf set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;Axiom &#8801; Extra_ax &#8746; Sent &#8746; Equality_ax &#8746; HF_ax &#8746; Special_ax &#8746; Induction_ax&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>AxiomP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;AxiomP x &#8801; x EQ &#171;extra_axiom&#187; OR SentP x OR Equality_axP x OR
                    HF_axP x OR Special_axP x OR Induction_axP x&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>AxiomP_eqvt</span><span> </span><span class="delimiter">[</span><span>eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(p &#8729; AxiomP x) = AxiomP (p &#8729; x)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>AxiomP_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>AxiomP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; AxiomP x &#10231; a &#9839; x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>AxiomP_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eval_fm_AxiomP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;eval_fm e (AxiomP x) &#10231; &#10214;x&#10215;e &#8712; Axiom&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>AxiomP_def</span><span> </span><span>Axiom_def</span><span> </span><span>Extra_ax_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>Equality_axP.simps</span><span> </span><span>HF_axP.simps</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>eval_quot_fm_ignore</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>AxiomP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (AxiomP t)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>AxiomP_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The predicate &#8249;ModPonP&#8250;, for the inference rule Modus Ponens&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ModPon</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hf &#8658; hf &#8658; hf &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;ModPon x y z &#8801; (y = q_Imp x z)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ModPonP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; tm &#8658; tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ModPonP x y z = (y EQ Q_Imp x z)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ModPonP_eqvt</span><span> </span><span class="delimiter">[</span><span>eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(p &#8729; ModPonP x y z) = ModPonP (p &#8729; x) (p &#8729; y) (p &#8729; z)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ModPonP_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ModPonP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; ModPonP x y z &#10231; a &#9839; x &#8743; a &#9839; y &#8743; a &#9839; z&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ModPonP_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eval_fm_ModPonP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;eval_fm e (ModPonP x y z) &#10231; ModPon &#10214;x&#10215;e &#10214;y&#10215;e &#10214;z&#10215;e&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ModPon_def</span><span> </span><span>ModPonP_def</span><span> </span><span>q_defs</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ModPonP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (ModPonP t u v)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ModPonP_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ModPonP_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(ModPonP t u v)(i::=w) = ModPonP (subst i w t) (subst i w u) (subst i w v)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ModPonP_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The predicate &#8249;ExistsP&#8250;, for the existential rule&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Definition&#8250;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  &quot;&#8866; A IMP B &#10233; atom i &#9839; B &#10233;  &#8866; (Ex i A) IMP B&quot; *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Exists</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hf &#8658; hf &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Exists p q &#8801; (&#8707;x x&#39; y v. Form x &#8743; VarNonOccForm v y &#8743; AbstForm v 0 x x&#39; &#8743;
                p = q_Imp x y &#8743; q = q_Imp (q_Ex x&#39;) y)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>ExistsP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; tm &#8658; fm&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom x &#9839; (p,q,v,y,x&#39;); atom x&#39; &#9839; (p,q,v,y);
    atom y &#9839; (p,q,v); atom v &#9839; (p,q)&#10215; &#10233;
  ExistsP p q = Ex x (Ex x&#39; (Ex y (Ex v (FormP (Var x) AND
                    VarNonOccFormP (Var v) (Var y) AND
                    AbstFormP (Var v) Zero (Var x) (Var x&#39;) AND
                    p EQ Q_Imp (Var x) (Var y) AND
                    q EQ Q_Imp (Q_Ex (Var x&#39;)) (Var y)))))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>ExistsP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>ExistsP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; ExistsP p q &#10231; a &#9839; p &#8743; a &#9839; q&quot;</span></span></span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eval_fm_ExistsP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;eval_fm e (ExistsP p q) &#10231; Exists &#10214;p&#10215;e &#10214;q&#10215;e&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis2</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ExistsP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (ExistsP p q)&quot;</span></span></span><span>   </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis3</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x&#39;</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>v</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom x &#9839; (p,q,v,y,x&#39;)&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;atom x&#39; &#9839; (p,q,v,y)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom y &#9839; (p,q,v)&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;atom v &#9839; (p,q)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thesis2</span><span> </span><span class="var">?thesis3</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Exists_def</span><span> </span><span>q_defs</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ExistsP_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(ExistsP p q)(j::=w) = ExistsP (subst j w p) (subst j w q)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x&#39;</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>v</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom x &#9839; (j,w,p,q,v,y,x&#39;)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom x&#39; &#9839; (j,w,p,q,v,y)&quot;</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;atom y &#9839; (j,w,p,q,v)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom v &#9839; (j,w,p,q)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ExistsP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>x&#39;</span><span> </span><span>y</span><span> </span><span>v</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Correctness&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Exists_imp_exists</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Exists p q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;A B i. p = &#10214;&#171;A IMP B&#187;&#10215;e &#8743; q = &#10214;&#171;(Ex i A) IMP B&#187;&#10215;e &#8743; atom i &#9839; B&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span>ax</span><span> </span><span>y</span><span> </span><span>v</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">:</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;Form x&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>noc</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;VarNonOccForm v y&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>abst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;AbstForm v 0 x ax&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;p = q_Imp x y&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q = q_Imp (q_Ex ax) y&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Exists_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>B</span><span class="delimiter">::</span><span>fm</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>B</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y = &#10214;&#171;B&#187;&#10215;e&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>vfresh</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom (decode_Var v) &#9839; B&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>VarNonOccForm_imp_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>A</span><span class="delimiter">::</span><span>fm</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x = &#10214;&#171;A&#187;&#10215;e&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Form_imp_is_fm</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>AbstForm_imp_abst_dbfm</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>abst</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>e</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ax</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ax = &#10214;quot_dbfm (abst_dbfm (decode_Var v) 0 (trans_fm [] A))&#10215;e&quot;</span></span></span><span>
</span><span>           </span><span class="string"><span class="delete"><span class="delete">&quot;p = &#10214;&#171;A IMP B&#187;&#10215;e&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span> </span><span>A</span><span> </span><span>B</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>quot_simps</span><span> </span><span>quot_fm_def</span><span> </span><span>q_defs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q = &#10214;&#171;(Ex (decode_Var v) A) IMP B&#187;&#10215;e&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>q</span><span> </span><span>A</span><span> </span><span>B</span><span> </span><span>ax</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>abst_trans_fm</span><span> </span><span>quot_simps</span><span> </span><span>q_defs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vfresh</span><span> </span><span>ax</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Exists_intro</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom i &#9839; B &#10233; Exists (&#10214;&#171;A IMP B&#187;&#10215;e) &#10214;&#171;(Ex i A) IMP B&#187;&#10215;e&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Exists_def</span><span> </span><span>quot_simps</span><span> </span><span>q_defs</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>metis</span><span> </span><span>AbstForm_trans_fm</span><span> </span><span>Form_quot_fm</span><span> </span><span>fresh_imp_VarNonOccForm</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Thus, we have precisely captured the codes of the specialisation axioms.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>Exists_iff_exists</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;Exists p q &#10231; (&#8707;A B i. p = &#10214;&#171;A IMP B&#187;&#10215;e &#8743; q = &#10214;&#171;(Ex i A) IMP B&#187;&#10215;e &#8743; atom i &#9839; B)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>Exists_imp_exists</span><span> </span><span>Exists_intro</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The predicate &#8249;SubstP&#8250;, for the substitution rule&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Although the substitution rule is derivable in the calculus, the derivation is
too complicated to reproduce within the proof function. It is much easier to
provide it as an immediate inference step, justifying its soundness in terms
of other inference rules.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Definition&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;This is the inference &#8249;H &#8866; A &#10233; H &#8866; A (i::=x)&#8250;&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Subst</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hf &#8658; hf &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;Subst p q &#8801; (&#8707;v u. SubstForm v u p q)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>SubstP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; tm &#8658; fm&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom u &#9839; (p,q,v); atom v &#9839; (p,q)&#10215; &#10233;
   SubstP p q = Ex v (Ex u (SubstFormP (Var v) (Var u) p q))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>SubstP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>SubstP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; SubstP p q &#10231; a &#9839; p &#8743; a &#9839; q&quot;</span></span></span><span>        </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eval_fm_SubstP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;eval_fm e (SubstP p q) &#10231; Subst &#10214;p&#10215;e &#10214;q&#10215;e&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis2</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SubstP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (SubstP p q)&quot;</span></span></span><span>                           </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis3</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>u</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>v</span><span class="delimiter">::</span><span>name</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom u &#9839; (p,q,v)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom v &#9839; (p,q)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thesis2</span><span> </span><span class="var">?thesis3</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Subst_def</span><span> </span><span>q_defs</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SubstP_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(SubstP p q)(j::=w) = SubstP (subst j w p) (subst j w q)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>u</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>v</span><span class="delimiter">::</span><span>name</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom u &#9839; (j,w,p,q,v)&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;atom v &#9839; (j,w,p,q)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>SubstP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>u</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>v</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Correctness&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Subst_imp_subst</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Subst p q&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Form p&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;A::fm. &#8707;i t. p = &#10214;&#171;A&#187;&#10215;e &#8743; q = &#10214;&#171;A(i::=t)&#187;&#10215;e&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>v</span><span> </span><span>u</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>subst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SubstForm v u p q&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Subst_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t</span><span class="delimiter">::</span><span>tm</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>substt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SubstForm v &#10214;&#171;t&#187;&#10215;e p q&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>SubstForm_def</span><span> </span><span>Term_imp_is_tm</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>SubstForm_imp_subst_fm</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>substt</span><span class="delimiter">]</span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>A</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;p = &#10214;&#171;A&#187;&#10215;e&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;q = &#10214;&#171;A(decode_Var v::=t)&#187;&#10215;e&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The predicate &#8249;PrfP&#8250;&#8250;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Prf(s,k,t) &#8801; LstSeq(s,k,t) &#8743; (&#8704;n&#8712;k)[Sent (s n) &#8744; (&#8707;m,l&#8712;n)[ModPon (s m) (s l) (s n)]]*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Prf</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hf &#8658; hf &#8658; hf &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Prf s k y &#8801; BuildSeq (&#955;x. x &#8712; Axiom) (&#955;u v w. ModPon v w u &#8744; Exists v u &#8744; Subst v u) s k y&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>PrfP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; tm &#8658; tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom l &#9839; (s,sl,m,n,sm,sn); atom sl &#9839; (s,m,n,sm,sn);
          atom m &#9839; (s,n,sm,sn); atom n &#9839; (s,k,sm,sn);
          atom sm &#9839; (s,sn); atom sn &#9839; (s)&#10215; &#10233;
    PrfP s k t =
      LstSeqP s k t AND
      All2 n (SUCC k) (Ex sn (HPair (Var n) (Var sn) IN s AND (AxiomP (Var sn) OR
                Ex m (Ex l (Ex sm (Ex sl (Var m IN Var n AND Var l IN Var n AND
                       HPair (Var m) (Var sm) IN s AND HPair (Var l) (Var sl) IN s AND
                       (ModPonP (Var sm) (Var sl) (Var sn) OR
                        ExistsP (Var sm) (Var sn) OR
                        SubstP (Var sm) (Var sn)))))))))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>PrfP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>PrfP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; PrfP s k t &#10231; a &#9839; s &#8743; a &#9839; k &#8743; a &#9839; t&quot;</span></span></span><span>      </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eval_fm_PrfP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;eval_fm e (PrfP s k t) &#10231; Prf &#10214;s&#10215;e &#10214;k&#10215;e &#10214;t&#10215;e&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>PrfP_imp_OrdP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;{PrfP s k t} &#8866; OrdP k&quot;</span></span></span><span>         </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thord</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>PrfP_imp_LstSeqP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{PrfP s k t} &#8866; LstSeqP s k t&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thlstseq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>PrfP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>           </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (PrfP s k t)&quot;</span></span></span><span>         </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thsf</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sm</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sn</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>atoms</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom l &#9839; (s,sl,m,n,sm,sn)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom sl &#9839; (s,m,n,sm,sn)&quot;</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;atom m &#9839; (s,n,sm,sn)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom n &#9839; (s,k,sm,sn)&quot;</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;atom sm &#9839; (s,sn)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom sn &#9839; (s)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thord</span><span> </span><span class="var">?thlstseq</span><span> </span><span class="var">?thsf</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>LstSeqP_OrdP</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis2</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>atoms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>       </span><span class="delimiter">(</span><span>simp</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>conj_cong</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>LstSeq_imp_Ord</span><span> </span><span>Prf_def</span><span> </span><span>BuildSeq_def</span><span> </span><span>Builds_def</span><span>
</span><span>             </span><span>ModPon_def</span><span> </span><span>Exists_def</span><span> </span><span>HBall_def</span><span> </span><span>HBex_def</span><span>
</span><span>             </span><span>Seq_iff_app</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>LstSeq_imp_Seq_succ</span><span class="delimiter">]</span><span>
</span><span>             </span><span>Ord_trans</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;succ &#10214;k&#10215;e&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>PrfP_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;(PrfP t u v)(j::=w) = PrfP (subst j w t) (subst j w u) (subst j w v)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sm</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sn</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom l &#9839; (t,u,v,j,w,sl,m,n,sm,sn)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom sl &#9839; (t,u,v,j,w,m,n,sm,sn)&quot;</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;atom m &#9839; (t,u,v,j,w,n,sm,sn)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom n &#9839; (t,u,v,j,w,sm,sn)&quot;</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;atom sm &#9839; (t,u,v,j,w,sn)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom sn &#9839; (t,u,v,j,w)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>PrfP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>l</span><span> </span><span>_</span><span> </span><span>sl</span><span> </span><span>m</span><span> </span><span>n</span><span> </span><span>sm</span><span> </span><span>sn</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The predicate &#8249;PfP&#8250;&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Pf</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hf &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Pf y &#8801; (&#8707;s k. Prf s k y)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>PfP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom k &#9839; (s,y); atom s &#9839; y&#10215; &#10233;
    PfP y = Ex k (Ex s (PrfP (Var s) (Var k) y))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>PfP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>PfP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; PfP y &#10231; a &#9839; y&quot;</span></span></span><span>           </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eval_fm_PfP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;eval_fm e (PfP y) &#10231; Pf &#10214;y&#10215;e&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis2</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>PfP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (PfP y)&quot;</span></span></span><span>                      </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thsf</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>k</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom k &#9839; (s,y)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom s &#9839; y&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thesis2</span><span> </span><span class="var">?thsf</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Pf_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>PfP_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(PfP t)(j::=w) = PfP (subst j w t)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>k</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom k &#9839; (s,t,j,w)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom s &#9839; (t,j,w)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>PfP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>k</span><span> </span><span>s</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ground_PfP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ground_fm (PfP y) = ground y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ground_aux_def</span><span> </span><span>ground_fm_aux_def</span><span> </span><span>supp_conv_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Proposition 4.4&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Left-to-Right Proof&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extra_axiom_imp_Pf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Pf &#10214;&#171;extra_axiom&#187;&#10215;e&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#171;extra_axiom&#187;&#10215;e &#8712; Extra_ax&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Extra_ax_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>eval_quot_fm_ignore</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Pf_def</span><span> </span><span>Prf_def</span><span> </span><span>Axiom_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>BuildSeq_exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>boolean_axioms_imp_Pf</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#945; &#8712; boolean_axioms&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Pf &#10214;&#171;&#945;&#187;&#10215;e&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#171;&#945;&#187;&#10215;e &#8712; Sent&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>boolean_axioms.cases</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Sent_def</span><span> </span><span>Sent_axioms_def</span><span> </span><span>quot_Disj</span><span> </span><span>quot_Neg</span><span> </span><span>q_defs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Pf_def</span><span> </span><span>Prf_def</span><span> </span><span>Axiom_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>BuildSeq_exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>equality_axioms_imp_Pf</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#945; &#8712; equality_axioms&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Pf &#10214;&#171;&#945;&#187;&#10215;e&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#171;&#945;&#187;&#10215;e &#8712; Equality_ax&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>equality_axioms_def</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Equality_ax_def</span><span> </span><span>eval_quot_fm_ignore</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Pf_def</span><span> </span><span>Prf_def</span><span> </span><span>Axiom_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>BuildSeq_exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HF_axioms_imp_Pf</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#945; &#8712; HF_axioms&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Pf &#10214;&#171;&#945;&#187;&#10215;e&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#171;&#945;&#187;&#10215;e &#8712; HF_ax&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>HF_axioms_def</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>HF_ax_def</span><span> </span><span>eval_quot_fm_ignore</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Pf_def</span><span> </span><span>Prf_def</span><span> </span><span>Axiom_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>BuildSeq_exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>special_axioms_imp_Pf</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#945; &#8712; special_axioms&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Pf &#10214;&#171;&#945;&#187;&#10215;e&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#171;&#945;&#187;&#10215;e &#8712; Special_ax&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>special_axioms_into_Special_ax</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Pf_def</span><span> </span><span>Prf_def</span><span> </span><span>Axiom_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>BuildSeq_exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>induction_axioms_imp_Pf</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#945; &#8712; induction_axioms&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Pf &#10214;&#171;&#945;&#187;&#10215;e&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#171;&#945;&#187;&#10215;e &#8712; Induction_ax&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>induction_axioms_into_Induction_ax</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Pf_def</span><span> </span><span>Prf_def</span><span> </span><span>Axiom_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>BuildSeq_exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ModPon_imp_Pf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;Pf &#10214;Q_Imp x y&#10215;e; Pf &#10214;x&#10215;e&#10215; &#10233; Pf &#10214;y&#10215;e&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Pf_def</span><span> </span><span>Prf_def</span><span> </span><span>ModPon_def</span><span> </span><span>q_defs</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>BuildSeq_combine</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>quot_ModPon_imp_Pf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;Pf &#10214;&#171;&#945; IMP &#946;&#187;&#10215;e; Pf &#10214;&#171;&#945;&#187;&#10215;e&#10215; &#10233; Pf &#10214;&#171;&#946;&#187;&#10215;e&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ModPon_imp_Pf</span><span> </span><span>quot_fm_def</span><span> </span><span>quot_simps</span><span> </span><span>q_defs</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>quot_Exists_imp_Pf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;Pf &#10214;&#171;&#945; IMP &#946;&#187;&#10215;e; atom i &#9839; &#946;&#10215; &#10233; Pf &#10214;&#171;Ex i &#945; IMP &#946;&#187;&#10215;e&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Pf_def</span><span> </span><span>Prf_def</span><span> </span><span>Exists_def</span><span> </span><span>quot_simps</span><span> </span><span>q_defs</span><span> 
</span><span>            </span><span>intro</span><span class="delimiter">:</span><span> </span><span>BuildSeq_combine</span><span> </span><span>AbstForm_trans_fm_eq</span><span> </span><span>fresh_imp_VarNonOccForm</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>proved_imp_Pf</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; &#945;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H={}&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Pf &#10214;&#171;&#945;&#187;&#10215;e&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Hyp</span><span> </span><span>A</span><span> </span><span>H</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Extra</span><span> </span><span>H</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>extra_axiom_imp_Pf</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Bool</span><span> </span><span>A</span><span> </span><span>H</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>boolean_axioms_imp_Pf</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Eq</span><span> </span><span>A</span><span> </span><span>H</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>equality_axioms_imp_Pf</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>HF</span><span> </span><span>A</span><span> </span><span>H</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>HF_axioms_imp_Pf</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Spec</span><span> </span><span>A</span><span> </span><span>H</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>special_axioms_imp_Pf</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Ind</span><span> </span><span>A</span><span> </span><span>H</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>induction_axioms_imp_Pf</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>MP</span><span> </span><span>H</span><span> </span><span>A</span><span> </span><span>B</span><span> </span><span>H&#39;</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>quot_ModPon_imp_Pf</span><span> </span><span>Un_empty</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Exists</span><span> </span><span>H</span><span> </span><span>A</span><span> </span><span>B</span><span> </span><span>i</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>quot_Exists_imp_Pf</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>proved_imp_proved_PfP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{} &#8866; &#945; &#10233; {} &#8866; PfP &#171;&#945;&#187;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Sigma_fm_imp_thm</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>PfP_sf</span><span class="delimiter">]</span><span class="delimiter">)</span><span> 
</span><span>     </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ground_aux_def</span><span> </span><span>supp_conv_fresh</span><span> </span><span>proved_imp_Pf</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Right-to-Left Proof&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Sent_imp_hfthm</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; Sent&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;A. x = &#10214;&#171;A&#187;&#10215;e &#8743; {} &#8866; A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>y</span><span> </span><span>z</span><span> </span><span>w</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Form y&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Form z&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Form w&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>axs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Sent_axioms x y z w&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Sent_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>A</span><span class="delimiter">::</span><span>fm</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>B</span><span class="delimiter">::</span><span>fm</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>C</span><span class="delimiter">::</span><span>fm</span><span> 
</span><span>         </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y = &#10214;&#171;A&#187;&#10215;e&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>B</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;z = &#10214;&#171;B&#187;&#10215;e&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;w = &#10214;&#171;C&#187;&#10215;e&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Form_imp_is_fm</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;A. q_Imp y y = &#10214;&#171;A&#187;&#10215;e &#8743; {} &#8866; A&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>A</span><span> </span><span>quot_Disj</span><span> </span><span>quot_Neg</span><span> </span><span>q_defs</span><span> </span><span>hfthm.Bool</span><span> </span><span>boolean_axioms.intros</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;A. q_Imp y (q_Disj y z) = &#10214;&#171;A&#187;&#10215;e &#8743; {} &#8866; A&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;A IMP (A OR B)&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>                </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>A</span><span> </span><span>B</span><span> </span><span>quot_Disj</span><span> </span><span>quot_Neg</span><span> </span><span>q_defs</span><span> </span><span>hfthm.Bool</span><span> </span><span>boolean_axioms.intros</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;A. q_Imp (q_Disj y y) y = &#10214;&#171;A&#187;&#10215;e &#8743; {} &#8866; A&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;(A OR A) IMP A&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>                </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>A</span><span> </span><span>quot_Disj</span><span> </span><span>quot_Neg</span><span> </span><span>q_defs</span><span> </span><span>hfthm.Bool</span><span> </span><span>boolean_axioms.intros</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;A. q_Imp (q_Disj y (q_Disj z w)) (q_Disj (q_Disj y z) w) = &#10214;&#171;A&#187;&#10215;e &#8743; {} &#8866; A&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;(A OR (B OR C)) IMP ((A OR B) OR C)&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>                </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>A</span><span> </span><span>B</span><span> </span><span>C</span><span> </span><span>quot_Disj</span><span> </span><span>quot_Neg</span><span> </span><span>q_defs</span><span> </span><span>hfthm.Bool</span><span> </span><span>boolean_axioms.intros</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;A. q_Imp (q_Disj y z) (q_Imp (q_Disj (q_Neg y) w) (q_Disj z w)) = &#10214;&#171;A&#187;&#10215;e &#8743; {} &#8866; A&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;(A OR B) IMP ((Neg A OR C) IMP (B OR C))&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>                </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>A</span><span> </span><span>B</span><span> </span><span>C</span><span> </span><span>quot_Disj</span><span> </span><span>quot_Neg</span><span> </span><span>q_defs</span><span> </span><span>hfthm.Bool</span><span> </span><span>boolean_axioms.intros</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>axs</span><span> </span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>Sent_axioms_def</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Extra_ax_imp_hfthm</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; Extra_ax&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>A</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x = &#10214;&#171;A&#187;&#10215;e &#8743; {} &#8866; A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Extra_ax_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>eval_quot_fm_ignore</span><span> </span><span>hfthm.Extra</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Equality_ax_imp_hfthm</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; Equality_ax&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>A</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x = &#10214;&#171;A&#187;&#10215;e &#8743; {} &#8866; A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Equality_ax_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>eval_quot_fm_ignore</span><span> </span><span>hfthm.Eq</span><span> </span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>equality_axioms_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HF_ax_imp_hfthm</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; HF_ax&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>A</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x = &#10214;&#171;A&#187;&#10215;e &#8743; {} &#8866; A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>HF_ax_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>eval_quot_fm_ignore</span><span> </span><span>hfthm.HF</span><span> </span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>HF_axioms_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Special_ax_imp_hfthm</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; Special_ax&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>A</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x = &#10214;&#171;A&#187;&#10215;e&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{} &#8866; A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Spec</span><span> </span><span>Special_ax_imp_special_axioms</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Induction_ax_imp_hfthm</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; Induction_ax&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>A</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x = &#10214;&#171;A&#187;&#10215;e&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{} &#8866; A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Induction_ax_imp_induction_axioms</span><span> </span><span>assms</span><span> </span><span>hfthm.Ind</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Exists_imp_hfthm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;Exists &#10214;&#171;A&#187;&#10215;e y; {} &#8866; A&#10215; &#10233; &#8707;B. y = &#10214;&#171;B&#187;&#10215;e &#8743; {} &#8866; B&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>Exists_imp_exists</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>e</span><span class="delimiter">=</span><span>e</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>anti_deduction</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Subst_imp_hfthm</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;Subst &#10214;&#171;A&#187;&#10215;e y; {} &#8866; A&#10215; &#10233; &#8707;B. y = &#10214;&#171;B&#187;&#10215;e &#8743; {} &#8866; B&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>Subst_imp_subst</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>e</span><span class="delimiter">=</span><span>e</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Subst</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eval_Neg_imp_Neg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#171;&#945;&#187;&#10215;e = q_Neg x &#10233; &#8707;A. &#945; = Neg A &#8743; &#10214;&#171;A&#187;&#10215;e = x&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>&#945;</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>fm.exhaust</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>quot_simps</span><span> </span><span>q_defs</span><span> </span><span>htuple_minus_1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eval_Disj_imp_Disj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#171;&#945;&#187;&#10215;e = q_Disj x y &#10233; &#8707;A B. &#945; = A OR B &#8743; &#10214;&#171;A&#187;&#10215;e = x &#8743; &#10214;&#171;B&#187;&#10215;e = y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>&#945;</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>fm.exhaust</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>quot_simps</span><span> </span><span>q_defs</span><span> </span><span>htuple_minus_1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Prf_imp_proved</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Prf s k x&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;A. x = &#10214;&#171;A&#187;&#10215;e &#8743; {} &#8866; A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>Prf_def</span><span> </span><span>Axiom_def</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>x</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>BuildSeq_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>B</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Extra_ax_imp_hfthm</span><span> </span><span>Sent_imp_hfthm</span><span> </span><span>Equality_ax_imp_hfthm</span><span> </span><span>HF_ax_imp_hfthm</span><span>
</span><span>                    </span><span>Special_ax_imp_hfthm</span><span> </span><span>Induction_ax_imp_hfthm</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>C</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>A</span><span class="delimiter">::</span><span>fm</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>B</span><span class="delimiter">::</span><span>fm</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y = &#10214;&#171;A&#187;&#10215;e&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{} &#8866; A&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;z = &#10214;&#171;B&#187;&#10215;e&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{} &#8866; B&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C.hyps</span><span> </span><span>ModPon_def</span><span> </span><span>q_Imp_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>MP_same</span><span> </span><span>eval_Neg_imp_Neg</span><span> </span><span>eval_Disj_imp_Disj</span><span> </span><span>Exists_imp_hfthm</span><span> </span><span>Subst_imp_hfthm</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>Pf_quot_imp_is_proved</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Pf &#10214;&#171;&#945;&#187;&#10215;e &#10233; {} &#8866; &#945;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Pf_def</span><span> </span><span>Prf_imp_proved</span><span> </span><span>eval_fm_inject</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Proposition 4.4!&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>proved_iff_proved_PfP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{} &#8866; &#945; &#10231; {} &#8866; PfP &#171;&#945;&#187;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Pf_quot_imp_is_proved</span><span> </span><span>emptyE</span><span> </span><span>eval_fm_PfP</span><span> </span><span>hfthm_sound</span><span> </span><span>proved_imp_proved_PfP</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span></pre>

</div>
</body>
</html>
