<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Predicates (Isabelle2020-RC3: March 2020)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Predicates</h1>

<span class="command">theory</span> <span class="name">Predicates</span><br/>
<span class="keyword">imports</span> <a href="SyntaxN.html"><span class="name">SyntaxN</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">chapter</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Basic Predicates&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Predicates</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>SyntaxN</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The Subset Relation&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>Subset</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; tm &#8658; fm&quot;</span></span></span><span>   </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SUBS&quot;</span></span></span><span> </span><span>150</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom z &#9839; (t, u) &#10233; t SUBS u = All2 z t ((Var z) IN u)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>Subset_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>Subset.simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Subset_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; t SUBS u &#10231; a &#9839; t &#8743; a &#9839; u&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>obtain_fresh</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;(t, u)&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>Subset.simps</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eval_fm_Subset</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;eval_fm e (Subset t u) &#10231; (&#10214;t&#10215;e &#8804; &#10214;u&#10215;e)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>obtain_fresh</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;(t, u)&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>Subset.simps</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subst_fm_Subset</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(t SUBS u)(i::=x) = (subst i x t) SUBS (subst i x u)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>j</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom j &#9839; (i,x,t,u)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Subset.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>j</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Subset_I</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insert ((Var i) IN t) H &#8866; (Var i) IN u&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom i &#9839; (t,u)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;B &#8712; H. atom i &#9839; B&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; t SUBS u&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>Subset.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Subset_D</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>major</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; t SUBS u&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>minor</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; a IN t&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; a IN u&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom i &#9839; (t, u)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; (Var i IN t IMP Var i IN u) (i::=a)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Subset.simps</span><span> </span><span>major</span><span> </span><span>All_D</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>MP_same</span><span> </span><span>minor</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Subset_E</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; t SUBS u &#10233; H &#8866; a IN t &#10233; insert (a IN u) H &#8866; A &#10233; H &#8866; A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Subset_D</span><span> </span><span>cut_same</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Subset_cong</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; t EQ t&#39; &#10233; H &#8866; u EQ u&#39; &#10233; H &#8866; t SUBS u IFF t&#39; SUBS u&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>P2_cong</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Set_MP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x SUBS y &#8712; H &#10233; z IN x &#8712; H &#10233; insert (z IN y) H &#8866; A &#10233; H &#8866; A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Assume</span><span> </span><span>Subset_D</span><span> </span><span>cut_same</span><span> </span><span>insert_absorb</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Zero_Subset_I</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; Zero SUBS t&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{} &#8866; Zero SUBS t&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>obtain_fresh</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;(Zero,t)&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Subset_I</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>thin</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Zero_SubsetE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; A &#10233; insert (Zero SUBS X) H &#8866; A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>thin1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Subset_Zero_D</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; t SUBS Zero&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; t EQ Zero&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom i &#9839; t&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{t SUBS Zero} &#8866; t EQ Zero&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Eq_Zero_I</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>A</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{Var i IN t, t SUBS Zero} &#8866; A&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Hyp</span><span> </span><span>Subset_D</span><span> </span><span>insertI1</span><span> </span><span>thin1</span><span> </span><span>Mem_Zero_E</span><span> </span><span>cut1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>cut1</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Subset_refl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; t SUBS t&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom i &#9839; t&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Assume</span><span> </span><span>Subset_I</span><span> </span><span>empty_iff</span><span> </span><span>fresh_Pair</span><span> </span><span>thin0</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Eats_Subset_Iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; Eats x y SUBS z IFF (x SUBS z) AND (y IN z)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom i &#9839; (x,y,z)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{} &#8866; (Eats x y SUBS z) IFF (x SUBS z AND y IN z)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Iff_I</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{Eats x y SUBS z} &#8866; x SUBS z AND y IN z&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Conj_I</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{Eats x y SUBS z} &#8866; x SUBS z&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Subset_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i</span><span class="delimiter">=</span><span>i</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Subset_D</span><span> </span><span>Mem_Eats_I1</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{Eats x y SUBS z} &#8866; y IN z&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Subset_D</span><span> </span><span>Assume</span><span> </span><span>Mem_Eats_I2</span><span> </span><span>Refl</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{x SUBS z AND y IN z} &#8866; Eats x y SUBS z&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>Subset_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i</span><span class="delimiter">=</span><span>i</span><span class="delimiter">]</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Subset_D</span><span> </span><span>Mem_cong</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>Iff_MP2_same</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>thin0</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Eats_Subset_I</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; x SUBS z &#10233; H &#8866; y IN z &#10233; H &#8866; Eats x y SUBS z&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Conj_I</span><span> </span><span>Eats_Subset_Iff</span><span> </span><span>Iff_MP2_same</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Eats_Subset_E</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;insert (x SUBS z) (insert (y IN z) H) &#8866; C &#10233; insert (Eats x y SUBS z) H &#8866; C&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Conj_E</span><span> </span><span>Eats_Subset_Iff</span><span> </span><span>Iff_MP_left&#39;</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A surprising proof: a consequence of @{thm Eats_Subset_Iff} and reflexivity!&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Subset_Eats_I</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; x SUBS Eats x y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Conj_E1</span><span> </span><span>Eats_Subset_Iff</span><span> </span><span>Iff_MP_same</span><span> </span><span>Subset_refl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SUCC_Subset_I</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; x SUBS z &#10233; H &#8866; x IN z &#10233; H &#8866; SUCC x SUBS z&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Eats_Subset_I</span><span> </span><span>SUCC_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SUCC_Subset_E</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;insert (x SUBS z) (insert (x IN z) H) &#8866; C &#10233; insert (SUCC x SUBS z) H &#8866; C&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Eats_Subset_E</span><span> </span><span>SUCC_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Subset_trans0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{ a SUBS b, b SUBS c } &#8866; a SUBS c&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom i &#9839; (a,b,c)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Subset_I</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Subset_D</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Subset_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; a SUBS b &#10233; H &#8866; b SUBS c &#10233; H &#8866; a SUBS c&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Subset_trans0</span><span> </span><span>cut2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Subset_SUCC</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; a SUBS (SUCC a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>SUCC_def</span><span> </span><span>Subset_Eats_I</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>All2_Subset_lemma</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom l &#9839; (k&#39;,k) &#10233; {P} &#8866; P&#39; &#10233; {All2 l k P, k&#39; SUBS k} &#8866; All2 l k&#39; P&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ex_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Var l&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>ContraProve</span><span> </span><span>Set_MP</span><span> </span><span>cut1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>All2_Subset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;H &#8866; All2 l k P; H &#8866; k&#39; SUBS k; {P} &#8866; P&#39;; atom l &#9839; (k&#39;, k)&#10215; &#10233; H &#8866; All2 l k&#39; P&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cut2</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>All2_Subset_lemma</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Extensionality&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Extensionality</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; x EQ y IFF x SUBS y AND y SUBS x&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>j</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>k</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>atoms</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom i &#9839; (x,y)&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;atom j &#9839; (i,x,y)&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;atom k &#9839; (i,j,y)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{} &#8866; (Var i EQ y IFF Var i SUBS y AND y SUBS Var i)&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{} &#8866; ?scheme&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ind</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>j</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom j &#9839; (i, ?scheme)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>atoms</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{} &#8866; ?scheme(i::=Zero)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>atoms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{Zero EQ y} &#8866; y SUBS Zero&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Subset_cong</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>Assume</span><span> </span><span>Refl</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>Iff_MP_same</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Subset_refl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{Zero SUBS y, y SUBS Zero} &#8866; Zero EQ y&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>AssumeH</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Subset_Zero_D</span><span> </span><span>Sym</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{} &#8866; All i (All j (?scheme IMP ?scheme(i::=Var j) IMP ?scheme(i::=Eats (Var i) (Var j))))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>atoms</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Subset_cong</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>Refl</span><span> </span><span>Assume</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>Iff_MP_same</span><span class="delimiter">]</span><span> </span><span>Subset_Eats_I</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Mem_cong</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>Refl</span><span> </span><span>Assume</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>Iff_MP_same</span><span class="delimiter">]</span><span> </span><span>Mem_Eats_I2</span><span> </span><span>Refl</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Subset_cong</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>Assume</span><span> </span><span>Refl</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>Iff_MP_same</span><span class="delimiter">]</span><span> </span><span>Subset_refl</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Eq_Eats_I</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>k</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>Sym</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Set_MP</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>y</span><span class="delimiter">]</span><span> </span><span>Subset_D</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Var i&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>Disj_I1</span><span> </span><span>Disj_I2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Var_Eq_subst_Iff</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>Iff_MP_same</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{} &#8866; (Var i EQ y IFF Var i SUBS y AND y SUBS Var i)(i::=x)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Subst</span><span> </span><span>emptyE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>atoms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>thin0</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Equality_I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; y SUBS x &#10233; H &#8866; x SUBS y &#10233; H &#8866; x EQ y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Conj_I</span><span> </span><span>Extensionality</span><span> </span><span>Iff_MP2_same</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>EQ_imp_SUBS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insert (t EQ u) H &#8866; (t SUBS u)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{t EQ u} &#8866; (t SUBS u)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Assume</span><span> </span><span>Conj_E</span><span> </span><span>Extensionality</span><span> </span><span>Iff_MP_left&#39;</span><span class="delimiter">)</span><span>
</span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Assume</span><span> </span><span>cut1</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>EQ_imp_SUBS2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insert (u EQ t) H &#8866; (t SUBS u)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>EQ_imp_SUBS</span><span> </span><span>Sym_L</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Equality_E</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insert (t SUBS u) (insert (u SUBS t) H) &#8866; A &#10233; insert (t EQ u) H &#8866; A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Conj_E</span><span> </span><span>Extensionality</span><span> </span><span>Iff_MP_left&#39;</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The Disjointness Relation&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The following predicate is defined in order to prove Lemma 2.3, Foundation&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>Disjoint</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom z &#9839; (t, u) &#10233; Disjoint t u = All2 z t (Neg ((Var z) IN u))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>Disjoint_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>Disjoint.simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Disjoint_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; Disjoint t u &#10231; a &#9839; t &#8743; a &#9839; u&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>j</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>j</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom j &#9839; (a,t,u)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Disjoint.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>j</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subst_fm_Disjoint</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(Disjoint t u)(i::=x) = Disjoint (subst i x t) (subst i x u)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>j</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>j</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom j &#9839; (i,x,t,u)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Disjoint.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>j</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Disjoint_cong</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; t EQ t&#39; &#10233; H &#8866; u EQ u&#39; &#10233; H &#8866; Disjoint t u IFF Disjoint t&#39; u&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>P2_cong</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Disjoint_I</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insert ((Var i) IN t) (insert ((Var i) IN u) H) &#8866; Fls&quot;</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;atom i &#9839; (t,u)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;B &#8712; H. atom i &#9839; B&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; Disjoint t u&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>Disjoint.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>insert_commute</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Disjoint_E</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>major</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; Disjoint t u&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>minor</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; a IN t&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; a IN u&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom i &#9839; (t, u)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; (Var i IN t IMP Neg (Var i IN u)) (i::=a)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Disjoint.simps</span><span> </span><span>major</span><span> </span><span>All_D</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>MP_same</span><span> </span><span>Neg_D</span><span> </span><span>minor</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Disjoint_commute</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{ Disjoint t u } &#8866; Disjoint u t&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom i &#9839; (t,u)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fresh_Pair</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Disjoint_I</span><span> </span><span>Disjoint_E</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Disjoint_commute_I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; Disjoint t u &#10233; H &#8866; Disjoint u t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Disjoint_commute</span><span> </span><span>cut1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Disjoint_commute_D</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insert (Disjoint t u) H &#8866; A &#10233; insert (Disjoint u t) H &#8866; A&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Assume</span><span> </span><span>Disjoint_commute_I</span><span> </span><span>cut_same</span><span> </span><span>insert_commute</span><span> </span><span>thin1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Zero_Disjoint_I1</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; Disjoint Zero t&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom i &#9839; t&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{} &#8866; Disjoint Zero t&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Disjoint_I</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span class="delimiter">]</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>thin0</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Zero_Disjoint_I2</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; Disjoint t Zero&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Disjoint_commute</span><span> </span><span>Zero_Disjoint_I1</span><span> </span><span>cut1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Disjoint_Eats_D1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{ Disjoint (Eats x y) z } &#8866; Disjoint x z&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom i &#9839; (x,y,z)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Disjoint_I</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span class="delimiter">]</span><span class="delimiter">)</span><span>  
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Disjoint_E</span><span> </span><span>Mem_Eats_I1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Disjoint_Eats_D2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{ Disjoint (Eats x y) z } &#8866; Neg(y IN z)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom i &#9839; (x,y,z)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Disjoint_E</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate2</span><span class="delimiter">]</span><span> </span><span>Mem_Eats_I2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Disjoint_Eats_E</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;insert (Disjoint x z) (insert (Neg(y IN z)) H) &#8866; A &#10233; insert (Disjoint (Eats x y) z) H &#8866; A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cut_same</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>cut1</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>Disjoint_Eats_D2</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>Assume</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cut_same</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>cut1</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>Disjoint_Eats_D1</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>Hyp</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>thin</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Disjoint_Eats_E2</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;insert (Disjoint z x) (insert (Neg(y IN z)) H) &#8866; A &#10233; insert (Disjoint z (Eats x y)) H &#8866; A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Disjoint_Eats_E</span><span> </span><span>Disjoint_commute_D</span><span class="delimiter">)</span><span>
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Disjoint_Eats_Imp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{ Disjoint x z, Neg(y IN z) } &#8866; Disjoint (Eats x y) z&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span class="string"><span class="delete"><span class="delete">&quot;atom i &#9839; (x,y,z)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Disjoint_I</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span class="delimiter">]</span><span>  </span><span>Disjoint_E</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate3</span><span class="delimiter">]</span><span> 
</span><span>                    </span><span>Mem_cong</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>Assume</span><span> </span><span>Refl</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>Iff_MP_same</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Disjoint_Eats_I</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; Disjoint x z &#10233; insert (y IN z) H &#8866; Fls &#10233; H &#8866; Disjoint (Eats x y) z&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Neg_I</span><span> </span><span>cut2</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>Disjoint_Eats_Imp</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Disjoint_Eats_I2</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; Disjoint z x &#10233; insert (y IN z) H &#8866; Fls &#10233; H &#8866; Disjoint z (Eats x y)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Disjoint_Eats_I</span><span> </span><span>Disjoint_commute</span><span> </span><span>cut1</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The Foundation Theorem&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Foundation_lemma</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom i &#9839; z&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{ All2 i z (Neg (Disjoint (Var i) z)) } &#8866; Neg (Var i IN z) AND Disjoint (Var i) z&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>j</span><span class="delimiter">::</span><span>name</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>j</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom j &#9839; (z,i)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ind</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>j</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i</span><span> </span><span>j</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ex_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>Zero</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ex_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;Eats (Var i) (Var j)&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ContraAssume</span><span> </span><span>insertI1</span><span> </span><span>insert_commute</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ContraProve</span><span> </span><span>Disjoint_Eats_Imp</span><span> </span><span>rotate2</span><span> </span><span>thin1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Assume</span><span> </span><span>Disj_I1</span><span> </span><span>anti_deduction</span><span> </span><span>rotate3</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>Foundation</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom i &#9839; z &#10233; {} &#8866; All2 i z (Neg (Disjoint (Var i) z)) IMP z EQ Zero&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Eq_Zero_I</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cut_same</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Neg ((Var i) IN z) AND Disjoint (Var i) z)&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Foundation_lemma</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>cut1</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Mem_Neg_refl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{} &#8866; Neg (x IN x)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom i &#9839; x&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{} &#8866; Disjoint x (Eats Zero x)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cut_same</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>Foundation</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>z</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Eats Zero x&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cut_same</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Disjoint x (Eats Zero x)&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>    
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Assume</span><span> </span><span>thin1</span><span> </span><span>Disjoint_cong</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>Assume</span><span> </span><span>Refl</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>Iff_MP_same</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Assume</span><span> </span><span>AssumeH</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>Disjoint_E</span><span> </span><span>Mem_Eats_I2</span><span> </span><span>Refl</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Disjoint_Eats_D2</span><span> </span><span>Disjoint_commute</span><span> </span><span>cut_same</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Mem_refl_E</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insert (x IN x) H &#8866; A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Disj_I1</span><span> </span><span>Mem_Neg_refl</span><span> </span><span>anti_deduction</span><span> </span><span>thin0</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Mem_non_refl</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; x IN x&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Mem_refl_E</span><span> </span><span>assms</span><span> </span><span>cut_same</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Mem_Neg_sym</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{ x IN y, y IN x } &#8866; Fls&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom i &#9839; (x,y)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{} &#8866; Disjoint x (Eats Zero y) OR Disjoint y (Eats Zero x)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cut_same</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>Foundation</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i</span><span class="delimiter">=</span><span>i</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>z</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Eats (Eats Zero y) x&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>Disjoint_Eats_E2</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate2</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Disj_I2</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Assume</span><span> </span><span>EQ_imp_SUBS2</span><span> </span><span>Subset_D</span><span> </span><span>insert_commute</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>Disj_I1</span><span> </span><span>Disjoint_cong</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>Hyp</span><span> </span><span>Refl</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>Iff_MP_same</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>cut0</span><span> </span><span>Disjoint_Eats_E2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Mem_not_sym</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insert (x IN y) (insert (y IN x) H) &#8866; A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cut_thin</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>Mem_Neg_sym</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The Ordinal Property&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>OrdP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom y &#9839; (x, z); atom z &#9839; x&#10215; &#10233;
    OrdP x = All2 y x ((Var y) SUBS x AND  All2 z (Var y) ((Var z) SUBS (Var y)))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>OrdP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>OrdP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; OrdP x &#10231; a &#9839; x&quot;</span></span></span><span>       </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eval_fm_OrdP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;eval_fm e (OrdP x) &#10231; Ord &#10214;x&#10215;e&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>z</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom z &#9839; x&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom y &#9839; (x, z)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thesis2</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>OrdP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>y</span><span> </span><span>_</span><span> </span><span>z</span><span class="delimiter">]</span><span> </span><span>Ord_def</span><span> </span><span>Transset_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subst_fm_OrdP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(OrdP t)(i::=x) = OrdP (subst i x t)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>z</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom z &#9839; (t,i,x)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom y &#9839; (t,i,x,z)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>OrdP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>y</span><span> </span><span>_</span><span> </span><span>z</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdP_cong</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; x EQ x&#39; &#10233; H &#8866; OrdP x IFF OrdP x&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>P1_cong</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdP_Mem_lemma</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>z</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom z &#9839; (k,l)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insert (OrdP k) H &#8866; l IN k&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insert (OrdP k) H &#8866; l SUBS k AND All2 z l (Var z SUBS l)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>y</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom y &#9839; (k,l,z)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insert (OrdP k) H 
        &#8866; (Var y IN k IMP (Var y SUBS k AND All2 z (Var y) (Var z SUBS Var y)))(y::=l)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>All_D</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>OrdP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>y</span><span> </span><span>_</span><span> </span><span>z</span><span class="delimiter">]</span><span> </span><span>y</span><span> </span><span>z</span><span> </span><span>Assume</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;... = l IN k IMP (l SUBS k AND All2 z l (Var z SUBS l))&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>y</span><span> </span><span>z</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>MP_same</span><span> </span><span>l</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdP_Mem_E</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom z &#9839; (k,l)&quot;</span></span></span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;insert (OrdP k) H &#8866; l IN k&quot;</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;insert (l SUBS k) (insert (All2 z l (Var z SUBS l)) H) &#8866; A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insert (OrdP k) H &#8866; A&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>OrdP_Mem_lemma</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>cut_same</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>insert_commute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>thin1</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdP_Mem_imp_Subset</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>k</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; k IN l&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; OrdP l&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; k SUBS l&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>obtain_fresh</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(l,k)&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cut_same</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>l</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>k</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>OrdP_Mem_E</span><span> </span><span>thin1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SUCC_Subset_Ord_lemma</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{ k&#39; IN k, OrdP k } &#8866; SUCC k&#39; SUBS k&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Assume</span><span> </span><span>thin1</span><span> </span><span>OrdP_Mem_imp_Subset</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SUCC_Subset_Ord</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; k&#39; IN k &#10233; H &#8866; OrdP k &#10233; H &#8866; SUCC k&#39; SUBS k&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>cut2</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>SUCC_Subset_Ord_lemma</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdP_Trans_lemma</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{ OrdP k, i IN j, j IN k } &#8866; i IN k&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom m &#9839; (i,j,k)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>OrdP_Mem_E</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>m</span><span> </span><span>k</span><span> </span><span>j</span><span class="delimiter">]</span><span> </span><span>Subset_D</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate3</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdP_Trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866;  OrdP k &#10233; H &#8866; i IN j &#10233; H &#8866; j IN k &#10233; H  &#8866; i IN k&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>cut3</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>OrdP_Trans_lemma</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Ord_IN_Ord0</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; l IN k&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insert (OrdP k) H &#8866; OrdP l&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>z</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>z</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom z &#9839; (k,l)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom y &#9839; (k,l,z)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{Var y IN l, OrdP k, l IN k} &#8866; All2 z (Var y) (Var z SUBS Var y)&quot;</span></span></span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>y</span><span> </span><span>z</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>insert_commute</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;OrdP k&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>OrdP_Mem_E</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>z</span><span> </span><span>k</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Var y&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>OrdP_Trans_lemma</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>All_I</span><span> </span><span>Neg_I</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{OrdP k, l IN k} &#8866; OrdP l&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>z</span><span> </span><span>y</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>OrdP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>y</span><span> </span><span>l</span><span> </span><span>z</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>insert_commute</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;OrdP k&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>OrdP_Mem_E</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>y</span><span> </span><span>k</span><span> </span><span>l</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Assume</span><span> </span><span>thin1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>All_E</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Var y&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>thin1</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Assume</span><span> </span><span>anti_deduction</span><span> </span><span>insert_commute</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>Assume</span><span> </span><span>l</span><span> </span><span>cut2</span><span> </span><span>thin1</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Ord_IN_Ord</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; l IN k &#10233; H &#8866; OrdP k &#10233; H &#8866; OrdP l&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_IN_Ord0</span><span> </span><span>cut_same</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdP_I</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insert (Var y IN x) H &#8866; (Var y) SUBS x&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insert (Var z IN Var y) (insert (Var y IN x) H) &#8866; (Var z) SUBS (Var y)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom y &#9839; (x, z)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;B &#8712; H. atom y &#9839; B&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;atom z &#9839; x&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;B &#8712; H. atom z &#9839; B&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; OrdP x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdP_Zero</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; OrdP Zero&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>y</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>z</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom y &#9839; z&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{} &#8866; OrdP Zero&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>OrdP_I</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>y</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>z</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>thin0</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdP_SUCC_I0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{ OrdP k } &#8866; OrdP (SUCC k)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>w</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>z</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>atoms</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom w &#9839; (k,y,z)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom y &#9839; (k,z)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom z &#9839; k&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{Var y IN SUCC k, OrdP k} &#8866; Var y SUBS SUCC k&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Mem_SUCC_E</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>OrdP_Mem_E</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>w</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Var y&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>rotate2</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>atoms</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Assume</span><span> </span><span>Subset_SUCC</span><span> </span><span>Subset_trans</span><span class="delimiter">)</span><span>   
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>EQ_imp_SUBS</span><span> </span><span>Subset_SUCC</span><span> </span><span>Subset_trans</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>in_case</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{Var y IN k, Var z IN Var y, OrdP k} &#8866; Var z SUBS Var y&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>OrdP_Mem_E</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>w</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Var y&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>rotate3</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>atoms</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span>  </span><span>All2_E</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>thin1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{Var y EQ k, Var z IN k, OrdP k} &#8866; Var z SUBS Var y&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>AssumeH</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>AssumeH</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>EQ_imp_SUBS2</span><span> </span><span>OrdP_Mem_imp_Subset</span><span> </span><span>Subset_trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>eq_case</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{Var y EQ k, Var z IN Var y, OrdP k} &#8866; Var z SUBS Var y&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cut3</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>EQ_imp_SUBS</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>cut1</span><span class="delimiter">]</span><span> </span><span>Subset_D</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{Var z IN Var y, Var y IN SUCC k, OrdP k} &#8866; Var z SUBS Var y&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>rotate2</span><span> </span><span>Mem_SUCC_E</span><span> </span><span>in_case</span><span> </span><span>eq_case</span><span class="delimiter">)</span><span>   
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>OrdP_I</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span> </span><span>2</span><span class="delimiter">]</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>atoms</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdP_SUCC_I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; OrdP k &#10233; H &#8866; OrdP (SUCC k)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>OrdP_SUCC_I0</span><span> </span><span>cut1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Zero_In_OrdP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{ OrdP x } &#8866; x EQ Zero OR Zero IN x&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>j</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom i &#9839; x&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>j</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom j &#9839; (x,i)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cut_thin</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>HB</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{OrdP x}&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>Foundation</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i</span><span class="delimiter">=</span><span>i</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>z</span><span> </span><span class="delimiter">=</span><span> </span><span>x</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i</span><span> </span><span>j</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Assume</span><span> </span><span>Disj_I1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Disj_I2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cut_same</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Var i EQ Zero&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Iff_MP_same</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>Mem_cong</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>Assume</span><span> </span><span>Refl</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>Eq_Zero_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i</span><span class="delimiter">=</span><span>j</span><span class="delimiter">]</span><span> </span><span>Ex_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;Var i&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Disjoint_E</span><span> </span><span>Subset_D</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdP_HPairE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insert (OrdP (HPair x y)) H &#8866; A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{ OrdP (HPair x y) } &#8866; A&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cut_same</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>Zero_In_OrdP</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>HPair_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Assume</span><span> </span><span>cut1</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>OrdP_HPairEH</span><span> </span><span class="delimiter">=</span><span> </span><span>OrdP_HPairE</span><span> </span><span>OrdP_HPairE</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate2</span><span class="delimiter">]</span><span> </span><span>OrdP_HPairE</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate3</span><span class="delimiter">]</span><span> </span><span>OrdP_HPairE</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate4</span><span class="delimiter">]</span><span> </span><span>OrdP_HPairE</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate5</span><span class="delimiter">]</span><span> 
</span><span>                 </span><span>OrdP_HPairE</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate6</span><span class="delimiter">]</span><span> </span><span>OrdP_HPairE</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate7</span><span class="delimiter">]</span><span> </span><span>OrdP_HPairE</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate8</span><span class="delimiter">]</span><span> </span><span>OrdP_HPairE</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate9</span><span class="delimiter">]</span><span> </span><span>OrdP_HPairE</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate10</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>OrdP_HPairEH</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Zero_Eq_HPairE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insert (Zero EQ HPair x y) H &#8866; A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Eats_EQ_Zero_E2</span><span> </span><span>HPair_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>Zero_Eq_HPairEH</span><span> </span><span class="delimiter">=</span><span> </span><span>Zero_Eq_HPairE</span><span> </span><span>Zero_Eq_HPairE</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate2</span><span class="delimiter">]</span><span> </span><span>Zero_Eq_HPairE</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate3</span><span class="delimiter">]</span><span> </span><span>Zero_Eq_HPairE</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate4</span><span class="delimiter">]</span><span> </span><span>Zero_Eq_HPairE</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate5</span><span class="delimiter">]</span><span> 
</span><span>                 </span><span>Zero_Eq_HPairE</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate6</span><span class="delimiter">]</span><span> </span><span>Zero_Eq_HPairE</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate7</span><span class="delimiter">]</span><span> </span><span>Zero_Eq_HPairE</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate8</span><span class="delimiter">]</span><span> </span><span>Zero_Eq_HPairE</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate9</span><span class="delimiter">]</span><span> </span><span>Zero_Eq_HPairE</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate10</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>Zero_Eq_HPairEH</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HPair_Eq_ZeroE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insert (HPair x y EQ Zero) H &#8866; A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Sym_L</span><span> </span><span>Zero_Eq_HPairE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>HPair_Eq_ZeroEH</span><span> </span><span class="delimiter">=</span><span> </span><span>HPair_Eq_ZeroE</span><span> </span><span>HPair_Eq_ZeroE</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate2</span><span class="delimiter">]</span><span> </span><span>HPair_Eq_ZeroE</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate3</span><span class="delimiter">]</span><span> </span><span>HPair_Eq_ZeroE</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate4</span><span class="delimiter">]</span><span> </span><span>HPair_Eq_ZeroE</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate5</span><span class="delimiter">]</span><span> 
</span><span>                 </span><span>HPair_Eq_ZeroE</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate6</span><span class="delimiter">]</span><span> </span><span>HPair_Eq_ZeroE</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate7</span><span class="delimiter">]</span><span> </span><span>HPair_Eq_ZeroE</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate8</span><span class="delimiter">]</span><span> </span><span>HPair_Eq_ZeroE</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate9</span><span class="delimiter">]</span><span> </span><span>HPair_Eq_ZeroE</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate10</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>HPair_Eq_ZeroEH</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Induction on Ordinals&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdInd_lemma</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>j</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom (j::name) &#9839; (i,A)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{ OrdP (Var i) } &#8866; (All i (OrdP (Var i) IMP ((All2 j (Var i) (A(i::= Var j))) IMP A))) IMP A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>k</span><span class="delimiter">::</span><span>name</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom l &#9839; (i,j,A)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>k</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom k &#9839; (i,j,l,A)&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{ (All i (OrdP (Var i) IMP ((All2 j (Var i) (A(i::= Var j))) IMP A))) } 
        &#8866; (All2 l (Var i) (OrdP (Var l) IMP A(i::= Var l)))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ind</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>k</span><span class="delimiter">]</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>j</span><span> </span><span>k</span><span> </span><span>l</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>All_E</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;Var l&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>rotate5</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Assume</span><span> </span><span>Disj_I1</span><span> </span><span>anti_deduction</span><span> </span><span>thin1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ex_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;Var l&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>All_E</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;Var j&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>rotate6</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>ContraProve</span><span> </span><span>Iff_MP_same</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>Mem_cong</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>Refl</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Assume</span><span> </span><span>Ord_IN_Ord0</span><span> </span><span>ContraProve</span><span> </span><span>insert_commute</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Assume</span><span> </span><span>Neg_D</span><span> </span><span>thin1</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{ (All i (OrdP (Var i) IMP ((All2 j (Var i) (A(i::= Var j))) IMP A))) } 
          &#8866; (All2 l (Var i) (OrdP (Var l) IMP A(i::= Var l)))(i::= Eats Zero (Var i))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Subst</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>indlem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{ All i (OrdP (Var i) IMP ((All2 j (Var i) (A(i::= Var j))) IMP A)) } 
             &#8866; All2 l (Eats Zero (Var i)) (OrdP (Var l) IMP A(i::=Var l))&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>j</span><span> </span><span>l</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Imp_I</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cut_thin</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>indlem</span><span class="delimiter">,</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>HB</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{OrdP (Var i)}&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>All2_Eats_E</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>j</span><span> </span><span>l</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdInd</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>j</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom (j::name) &#9839; (i,A)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; OrdP (Var i)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; All i (OrdP (Var i) IMP (All2 j (Var i) (A(i::= Var j)) IMP A))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cut_thin</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>x</span><span class="delimiter">,</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>HB</span><span class="delimiter">=</span><span>H</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>MP_thin</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>OrdInd_lemma</span><span> </span><span>step</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>j</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdIndH</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom (j::name) &#9839; (i,A)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; All i (OrdP (Var i) IMP (All2 j (Var i) (A(i::= Var j)) IMP A))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insert (OrdP (Var i)) H &#8866; A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>thin1</span><span> </span><span>Assume</span><span> </span><span>OrdInd</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Linearity of Ordinals&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdP_linear_lemma</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>j</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom j &#9839; i&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{ OrdP (Var i) } &#8866; All j (OrdP (Var j) IMP (Var i IN Var j OR Var i EQ Var j OR Var j IN Var i))&quot;</span></span></span><span>
</span><span>         </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;_ &#8866; ?scheme&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>k</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>l</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>k</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom k &#9839; (i,j)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom l &#9839; (i,j,k)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom m &#9839; (i,j)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>OrdIndH</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i</span><span class="delimiter">=</span><span>i</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>j</span><span class="delimiter">=</span><span>k</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom k &#9839; (i, ?scheme)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>k</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fresh_Pair</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{} &#8866; All i (OrdP (Var i) IMP (All2 k (Var i) (?scheme(i::= Var k)) IMP ?scheme))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>j</span><span> </span><span>k</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>All_I</span><span> </span><span>Imp_I</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span><span> </span><span>1</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>OrdIndH</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i</span><span class="delimiter">=</span><span>j</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>j</span><span class="delimiter">=</span><span>l</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l</span><span>
</span><span>      </span><span class="comment">&#8213; &#8249;nested induction&#8250;</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fresh_Pair</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>All_I</span><span> </span><span>Imp_I</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Disj_3I</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Equality_I</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="comment">&#8213; &#8249;Now the opposite inclusion, @{term&quot;Var j SUBS Var i&quot;}&#8250;</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Subset_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>All2_E</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate4</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l</span><span> </span><span>m</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>ContraProve</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate3</span><span class="delimiter">]</span><span> </span><span>OrdP_Trans</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>ContraProve</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate3</span><span class="delimiter">]</span><span> </span><span>Mem_cong</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>Hyp</span><span> </span><span>Refl</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>Iff_MP2_same</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="comment">&#8213; &#8249;Now the opposite inclusion, @{term&quot;Var i SUBS Var j&quot;}&#8250;</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Subset_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>All2_E</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate6</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>All_E</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Var j&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>ContraProve</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate4</span><span class="delimiter">]</span><span> </span><span>Mem_cong</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>Hyp</span><span> </span><span>Refl</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>Iff_MP_same</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>ContraProve</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate4</span><span class="delimiter">]</span><span> </span><span>OrdP_Trans</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdP_linear_imp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{} &#8866; OrdP x IMP OrdP y IMP x IN y OR x EQ y OR y IN x&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>j</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>atoms</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom i &#9839; (x,y)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom j &#9839; (x,y,i)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{ OrdP (Var i) } &#8866; (OrdP (Var j) IMP (Var i IN Var j OR Var i EQ Var j OR Var j IN Var i))(j::=y)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>atoms</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>All_D</span><span> </span><span>OrdP_linear_lemma</span><span> </span><span>fresh_Pair</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{} &#8866; OrdP (Var i) IMP OrdP y IMP (Var i IN y OR Var i EQ y OR y IN Var i)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>atoms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{} &#8866; (OrdP (Var i) IMP OrdP y IMP (Var i IN y OR Var i EQ y OR y IN Var i))(i::=x)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Subst</span><span> </span><span>empty_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>atoms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdP_linear</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; OrdP x&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; OrdP y&quot;</span></span></span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;insert (x IN y) H &#8866; A&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insert (x EQ y) H &#8866; A&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insert (y IN x) H &#8866; A&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{ OrdP x, OrdP y } &#8866; x IN y OR x EQ y OR y IN x&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>OrdP_linear_imp</span><span> </span><span>Imp_Imp_commute</span><span> </span><span>anti_deduction</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>cut2</span><span> </span><span>Disj_E</span><span> </span><span>cut_same</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Zero_In_SUCC</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{OrdP k} &#8866; Zero IN SUCC k&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>OrdP_linear</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>OrdP_Zero</span><span> </span><span>OrdP_SUCC_I</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>SUCC_def</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The predicate &#8249;OrdNotEqP&#8250;&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>OrdNotEqP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; tm &#8658; fm&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;NEQ&quot;</span></span></span><span> </span><span>150</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;OrdNotEqP x y = OrdP x AND OrdP y AND (x IN y OR y IN x)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>OrdNotEqP_graph_aux_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdNotEqP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; OrdNotEqP x y &#10231; a &#9839; x &#8743; a &#9839; y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eval_fm_OrdNotEqP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;eval_fm e (OrdNotEqP x y) &#10231; Ord &#10214;x&#10215;e &#8743; Ord &#10214;y&#10215;e &#8743; &#10214;x&#10215;e &#8800; &#10214;y&#10215;e&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hmem_not_refl</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_linear</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdNotEqP_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(OrdNotEqP x y)(i::=t) = OrdNotEqP (subst i t x) (subst i t y)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdNotEqP_cong</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; x EQ x&#39; &#10233; H &#8866; y EQ y&#39; &#10233; H &#8866; OrdNotEqP x y IFF OrdNotEqP x&#39; y&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>P2_cong</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdNotEqP_self_contra</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{x NEQ x} &#8866; Fls&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdNotEqP_OrdP_E</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insert (OrdP x) (insert (OrdP y) H) &#8866; A &#10233; insert (x NEQ y) H &#8866; A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>thin1</span><span> </span><span>rotate2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdNotEqP_I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insert (x EQ y) H &#8866; Fls &#10233; H &#8866; OrdP x &#10233; H &#8866; OrdP y &#10233; H &#8866; x NEQ y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>OrdP_linear</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>ExFalso</span><span> </span><span>thin1</span><span> </span><span>Disj_I1</span><span> </span><span>Disj_I2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>OrdNotEqP.simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdNotEqP_imp_Neg_Eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{x NEQ y} &#8866; Neg (x EQ y)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>OrdNotEqP_cong</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>Iff_MP2_same</span><span class="delimiter">]</span><span>  </span><span>OrdNotEqP_self_contra</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>cut1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdNotEqP_E</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; x EQ y &#10233; insert (x NEQ y) H &#8866; A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ContraProve</span><span> </span><span>OrdNotEqP_imp_Neg_Eq</span><span> </span><span>rcut1</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Predecessor of an Ordinal&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdP_set_max_lemma</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>j</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom (j::name) &#9839; i&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>k</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom (k::name) &#9839; (i,j)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{} &#8866; (Neg (Var i EQ Zero) AND (All2 j (Var i) (OrdP (Var j)))) IMP 
              (Ex j (Var j IN Var i AND (All2 k (Var i) (Var k SUBS Var j))))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom l &#9839; (i,j,k)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ind</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>l</span><span> </span><span>i</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>j</span><span> </span><span>k</span><span> </span><span>l</span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Conj_E</span><span> </span><span>Refl</span><span> </span><span>Swap</span><span> </span><span>Imp_I</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>All_I</span><span> </span><span>Imp_I</span><span class="delimiter">)</span><span class="delimiter">+</span><span>  
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>thin1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>thin1</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate2</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Disj_EH</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Neg_Conj_E</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>All2_Eats_E1</span><span class="delimiter">)</span><span>   
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ex_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;Var l&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Mem_Eats_I2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Assume</span><span> </span><span>Eq_Zero_D</span><span> </span><span>rotate3</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Assume</span><span> </span><span>EQ_imp_SUBS</span><span> </span><span>Neg_D</span><span> </span><span>thin1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Cases</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Var j IN Var l&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ex_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;Var l&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Mem_Eats_I2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ex_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;Var l&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Mem_Eats_I2</span><span> </span><span>ContraProve</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ex_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;Var k&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Assume</span><span> </span><span>Subset_trans</span><span> </span><span>OrdP_Mem_imp_Subset</span><span> </span><span>thin1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ex_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;Var l&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Mem_Eats_I2</span><span> </span><span>ContraProve</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ContraProve</span><span> </span><span>EQ_imp_SUBS</span><span> </span><span>rotate3</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="comment">&#8213; &#8249;final case&#8250;</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>All2_Eats_E</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate4</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ex_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;Var j&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Mem_Eats_I1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>All2_E</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Var k&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>rotate3</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ex_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;Var k&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Assume</span><span> </span><span>NegNeg_I</span><span> </span><span>Neg_Disj_I</span><span> </span><span>rotate3</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cut_same</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;OrdP (Var j)&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>All2_E</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Var j&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>rotate3</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cut_same</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Var l EQ Var j OR Var l IN Var j&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>OrdP_linear</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Var l&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Var j&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Disj_CI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Assume</span><span> </span><span>ContraProve</span><span> </span><span>rotate7</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ContraProve</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate4</span><span class="delimiter">]</span><span> </span><span>EQ_imp_SUBS</span><span> </span><span>Subset_trans</span><span> </span><span>rotate3</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>ContraProve</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate4</span><span class="delimiter">]</span><span> </span><span>OrdP_Mem_imp_Subset</span><span> </span><span>Iff_MP2_same</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>Mem_cong</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdP_max_imp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>j</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom j &#9839; (x)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>k</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom k &#9839; (x,j)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;{ OrdP x, Neg (x EQ Zero) } &#8866; Ex j (Var j IN x AND (All2 k x (Var k SUBS Var j)))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom i &#9839; (x,j,k)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{} &#8866; ((Neg (Var i EQ Zero) AND (All2 j (Var i) (OrdP (Var j)))) IMP 
              (Ex j (Var j IN Var i AND (All2 k (Var i) (Var k SUBS Var j)))))(i::=x)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Subst</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>OrdP_set_max_lemma</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i</span><span> </span><span>k</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{ Neg (x EQ Zero) AND (All2 j x (OrdP (Var j))) } 
         &#8866; Ex j (Var j IN x AND (All2 k x (Var k SUBS Var j)))&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i</span><span> </span><span>j</span><span> </span><span>k</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>anti_deduction</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{ All2 j x (OrdP (Var j)), Neg (x EQ Zero) } 
             &#8866; Ex j (Var j IN x AND (All2 k x (Var k SUBS Var j)))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cut1</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Assume</span><span> </span><span>Conj_I</span><span> </span><span>thin1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{ OrdP x } &#8866; All2 j x (OrdP (Var j))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>j</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Assume</span><span> </span><span>Ord_IN_Ord</span><span> </span><span>thin1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>rcut1</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>OrdP.simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Case Analysis and Zero/SUCC Induction&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdP_cases_lemma</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom p &#9839; x&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;{ OrdP x, Neg (x EQ Zero) } &#8866; Ex p (OrdP (Var p) AND x EQ SUCC (Var p))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>j</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>k</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>j</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom j &#9839; (x,p)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>k</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom k &#9839; (x,j,p)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cut_same</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>OrdP_max_imp</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>j</span><span> </span><span>x</span><span> </span><span>k</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span> </span><span>j</span><span> </span><span>k</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ex_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;Var j&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Assume</span><span> </span><span>Ord_IN_Ord</span><span> </span><span>thin1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cut_same</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;OrdP (SUCC (Var j))&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Assume</span><span> </span><span>Ord_IN_Ord0</span><span> </span><span>OrdP_SUCC_I</span><span> </span><span>rotate2</span><span> </span><span>thin1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>OrdP_linear</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>x</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>Assume</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>Mem_SUCC_EH</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Mem_not_sym</span><span> </span><span>rotate3</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Mem_non_refl</span><span class="delimiter">,</span><span> </span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Mem_cong</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>Assume</span><span> </span><span>Refl</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>Iff_MP2_same</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>thin1</span><span> </span><span>All2_E</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SUCC (Var j)&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>rotate4</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdP_cases_disj</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom p &#9839; x&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;insert (OrdP x) H &#8866; x EQ Zero OR Ex p (OrdP (Var p) AND x EQ SUCC (Var p))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Disj_CI</span><span> </span><span>Assume</span><span> </span><span>cut2</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>OrdP_cases_lemma</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>p</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>Swap</span><span> </span><span>thin1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdP_cases_E</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;insert (x EQ Zero) H &#8866; A;
    insert (x EQ SUCC (Var k)) (insert (OrdP (Var k)) H) &#8866; A; 
    atom k &#9839; (x,A);   &#8704;C &#8712; H. atom k &#9839; C&#10215;
   &#10233; insert (OrdP x) H &#8866; A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cut_same</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>OrdP_cases_disj</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>k</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>insert_commute</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>thin1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdInd2_lemma</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;{ OrdP (Var i), A(i::= Zero), (All i (OrdP (Var i) IMP A IMP (A(i::= SUCC (Var i))))) } &#8866; A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>j</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>k</span><span class="delimiter">::</span><span>name</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>atoms</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom j &#9839; (i,A)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom k &#9839; (i,j,A)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>OrdIndH</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i</span><span class="delimiter">=</span><span>i</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>j</span><span class="delimiter">=</span><span>j</span><span class="delimiter">]</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>atoms</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>OrdP_cases_E</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>k</span><span class="delimiter">=</span><span>k</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>rotate3</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ContraProve</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate2</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Var_Eq_imp_subst_Iff</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Assume</span><span> </span><span>AssumeH</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>Iff_MP_same</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ex_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;Var k&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Neg_Imp_I</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cut_same</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A(i::=Var k)&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>All2_E</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Var k&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>rotate5</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Mem_SUCC_I2</span><span> </span><span>Mem_cong</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>Refl</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>Iff_MP2_same</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ContraProve</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate5</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Assume</span><span> </span><span>Iff_MP_left&#39;</span><span> </span><span>Var_Eq_subst_Iff</span><span> </span><span>thin1</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdInd2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; OrdP (Var i)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; A(i::= Zero)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; All i (OrdP (Var i) IMP A IMP (A(i::= SUCC (Var i))))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>cut3</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>OrdInd2_lemma</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdInd2H</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; A(i::= Zero)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; All i (OrdP (Var i) IMP A IMP (A(i::= SUCC (Var i))))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insert (OrdP (Var i)) H &#8866; A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>thin1</span><span> </span><span>Assume</span><span> </span><span>OrdInd2</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The predicate &#8249;HFun_Sigma&#8250;&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;To characterise the concept of a function using only bounded universal quantifiers.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;See the note after the proof of Lemma 2.3.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hfun_sigma</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hfun_sigma r &#8801; &#8704;z <span class="hidden">&#10073;</span><span class="bold">&#8712;</span> r. &#8704;z&#39; <span class="hidden">&#10073;</span><span class="bold">&#8712;</span> r. &#8707;x y x&#39; y&#39;. z = &#10216;x,y&#10217; &#8743; z&#39; = &#10216;x&#39;,y&#39;&#10217; &#8743; (x=x&#39; &#10230; y=y&#39;)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hfun_sigma_ord</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hfun_sigma_ord r &#8801; &#8704;z <span class="hidden">&#10073;</span><span class="bold">&#8712;</span> r. &#8704;z&#39; <span class="hidden">&#10073;</span><span class="bold">&#8712;</span> r. &#8707;x y x&#39; y&#39;. z = &#10216;x,y&#10217; &#8743; z&#39; = &#10216;x&#39;,y&#39;&#10217; &#8743; Ord x &#8743; Ord x&#39; &#8743; (x=x&#39; &#10230; y=y&#39;)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>HFun_Sigma</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom z &#9839; (r,z&#39;,x,y,x&#39;,y&#39;); atom z&#39; &#9839; (r,x,y,x&#39;,y&#39;); 
          atom x &#9839; (r,y,x&#39;,y&#39;); atom y &#9839; (r,x&#39;,y&#39;); atom x&#39; &#9839; (r,y&#39;); atom y&#39; &#9839; (r) &#10215; &#10233;
    HFun_Sigma r = 
         All2 z r (All2 z&#39; r (Ex x (Ex y (Ex x&#39; (Ex y&#39;
             (Var z EQ HPair (Var x) (Var y) AND Var z&#39; EQ HPair (Var x&#39;) (Var y&#39;)
              AND OrdP (Var x) AND OrdP (Var x&#39;) AND 
              ((Var x EQ Var x&#39;) IMP (Var y EQ Var y&#39;))))))))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>HFun_Sigma_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>HFun_Sigma_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; HFun_Sigma r &#10231; a &#9839; r&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eval_fm_HFun_Sigma</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;eval_fm e (HFun_Sigma r) &#10231; hfun_sigma_ord &#10214;r&#10215;e&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>z</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x&#39;</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y&#39;</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>z&#39;</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom z &#9839; (r,z&#39;,x,y,x&#39;,y&#39;)&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;atom z&#39; &#9839; (r,x,y,x&#39;,y&#39;)&quot;</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;atom x &#9839; (r,y,x&#39;,y&#39;)&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;atom y &#9839; (r,x&#39;,y&#39;)&quot;</span></span></span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;atom x&#39; &#9839; (r,y&#39;)&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;atom y&#39; &#9839; (r)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thesis2</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>HBall_def</span><span> </span><span>hfun_sigma_ord_def</span><span class="delimiter">,</span><span> </span><span>metis</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HFun_Sigma_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(HFun_Sigma r)(i::=t) = HFun_Sigma (subst i t r)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>z</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x&#39;</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y&#39;</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>z&#39;</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom z &#9839; (r,t,i,z&#39;,x,y,x&#39;,y&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom z&#39; &#9839; (r,t,i,x,y,x&#39;,y&#39;)&quot;</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;atom x &#9839; (r,t,i,y,x&#39;,y&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom y &#9839; (r,t,i,x&#39;,y&#39;)&quot;</span></span></span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;atom x&#39; &#9839; (r,t,i,y&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom y&#39; &#9839; (r,t,i)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>HFun_Sigma.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>z</span><span> </span><span>_</span><span> </span><span>z&#39;</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>x&#39;</span><span> </span><span>y&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HFun_Sigma_Zero</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; HFun_Sigma Zero&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>z</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x&#39;</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y&#39;</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>z&#39;</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>z&#39;&#39;</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom z&#39;&#39; &#9839; (z,z&#39;,x,y,x&#39;,y&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom z &#9839; (z&#39;,x,y,x&#39;,y&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom z&#39; &#9839; (x,y,x&#39;,y&#39;)&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;atom x &#9839; (y,x&#39;,y&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom y &#9839; (x&#39;,y&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom x&#39; &#9839; y&#39;&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{} &#8866; HFun_Sigma Zero&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>HFun_Sigma.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>z</span><span> </span><span>_</span><span> </span><span>z&#39;</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>x&#39;</span><span> </span><span>y&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>thin0</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Subset_HFun_Sigma</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{HFun_Sigma s, s&#39; SUBS s} &#8866; HFun_Sigma s&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>z</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x&#39;</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y&#39;</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>z&#39;</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>z&#39;&#39;</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom z&#39;&#39; &#9839; (z,z&#39;,x,y,x&#39;,y&#39;,s,s&#39;)&quot;</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;atom z &#9839; (z&#39;,x,y,x&#39;,y&#39;,s,s&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom z&#39; &#9839; (x,y,x&#39;,y&#39;,s,s&#39;)&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;atom x &#9839; (y,x&#39;,y&#39;,s,s&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom y &#9839; (x&#39;,y&#39;,s,s&#39;)&quot;</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;atom x&#39; &#9839; (y&#39;,s,s&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom y&#39; &#9839; (s,s&#39;)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>HFun_Sigma.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>z</span><span> </span><span>_</span><span> </span><span>z&#39;</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>x&#39;</span><span> </span><span>y&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ex_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;Var z&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Subset_D</span><span> </span><span>ContraProve</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>All_E</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;Var z&#39;&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Subset_D</span><span> </span><span>ContraProve</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Captures the property of being a relation, using fewer variables than the full definition&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HFun_Sigma_Mem_imp_HPair</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; HFun_Sigma r&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; a IN r&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xy</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom x &#9839; (y,a,r)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom y &#9839; (a,r)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; (Ex x (Ex y (a EQ HPair (Var x) (Var y))))&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;_ &#8866; ?concl&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x&#39;</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y&#39;</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>z</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>z&#39;</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>atoms</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom z &#9839; (z&#39;,x&#39;,y&#39;,x,y,a,r)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom z&#39; &#9839; (x&#39;,y&#39;,x,y,a,r)&quot;</span></span></span><span>
</span><span>                 </span><span class="string"><span class="delete"><span class="delete">&quot;atom x&#39; &#9839; (y&#39;,x,y,a,r)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom y&#39; &#9839; (x,y,a,r)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{HFun_Sigma r, a IN r} &#8866; ?concl&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xy</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>HFun_Sigma.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>z</span><span> </span><span>r</span><span> </span><span>z&#39;</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>x&#39;</span><span> </span><span>y&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>All_E</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>a</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>All_E</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>a</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Imp_E</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ex_EH</span><span> </span><span>Conj_EH</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ex_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;Var x&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ex_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;Var y&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cut2</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>assms</span><span class="delimiter">)</span><span class="delimiter">+</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>    
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The predicate &#8249;HDomain_Incl&#8250;&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;This is an internal version of @{term &quot;&#8704;x <span class="hidden">&#10073;</span><span class="bold">&#8712;</span> d. &#8707;y z. z <span class="hidden">&#10073;</span><span class="bold">&#8712;</span> r &#8743; z = &#10216;x,y&#10217;&quot;}.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>HDomain_Incl</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom x &#9839; (r,d,y,z); atom y &#9839; (r,d,z); atom z &#9839; (r,d)&#10215; &#10233;
    HDomain_Incl r d = All2 x d (Ex y (Ex z (Var z IN r AND Var z EQ HPair (Var x) (Var y))))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>HDomain_Incl_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>HDomain_Incl_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; HDomain_Incl r d &#10231; a &#9839; r &#8743; a &#9839; d&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span>eval_fm_HDomain_Incl</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;eval_fm e (HDomain_Incl r d) &#10231; &#10214;d&#10215;e &#8804; hdomain &#10214;r&#10215;e&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>z</span><span class="delimiter">::</span><span>name</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom x &#9839; (r,d,y,z)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom y &#9839; (r,d,z)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom z &#9839; (r,d)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thesis2</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>HDomain_Incl.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>y</span><span> </span><span>z</span><span class="delimiter">]</span><span> </span><span>hdomain_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HDomain_Incl_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;(HDomain_Incl r d)(i::=t) = HDomain_Incl (subst i t r) (subst i t d)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>z</span><span class="delimiter">::</span><span>name</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom x &#9839; (r,d,y,z,t,i)&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;atom y &#9839; (r,d,z,t,i)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom z &#9839; (r,d,t,i)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>HDomain_Incl.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>y</span><span> </span><span>z</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HDomain_Incl_Subset_lemma</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{ HDomain_Incl r k, k&#39; SUBS k } &#8866; HDomain_Incl r k&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>z</span><span class="delimiter">::</span><span>name</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom x &#9839; (r,k,k&#39;,y,z)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom y &#9839; (r,k,k&#39;,z)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom z &#9839; (r,k,k&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>HDomain_Incl.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>y</span><span> </span><span>z</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ex_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Var x&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>ContraProve</span><span> </span><span>Subset_D</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HDomain_Incl_Subset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; HDomain_Incl r k &#10233; H &#8866; k&#39; SUBS k &#10233; H &#8866; HDomain_Incl r k&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>HDomain_Incl_Subset_lemma</span><span> </span><span>cut2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HDomain_Incl_Mem_Ord</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; HDomain_Incl r k &#10233; H &#8866; k&#39; IN k &#10233; H &#8866; OrdP k &#10233; H &#8866; HDomain_Incl r k&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>HDomain_Incl_Subset</span><span> </span><span>OrdP_Mem_imp_Subset</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HDomain_Incl_Zero</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; HDomain_Incl r Zero&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>z</span><span class="delimiter">::</span><span>name</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom x &#9839; (r,y,z)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom y &#9839; (r,z)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom z &#9839; r&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{} &#8866; HDomain_Incl r Zero&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>HDomain_Incl.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>y</span><span> </span><span>z</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>thin0</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HDomain_Incl_Eats</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{ HDomain_Incl r d } &#8866; HDomain_Incl (Eats r (HPair d d&#39;)) (SUCC d)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>z</span><span class="delimiter">::</span><span>name</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom x &#9839; (r,d,d&#39;,y,z)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom y &#9839; (r,d,d&#39;,z)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>z</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom z &#9839; (r,d,d&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>HDomain_Incl.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>y</span><span> </span><span>z</span><span class="delimiter">]</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>Mem_SUCC_EH</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ex_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Var x&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ex_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Var y&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ex_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Var z&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Mem_Eats_I1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rotate2</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>Swap</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ex_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>d&#39;</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ex_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;HPair d d&#39;&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Mem_Eats_I2</span><span> </span><span>HPair_cong</span><span> </span><span>Sym</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HDomain_Incl_Eats_I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; HDomain_Incl r d &#10233; H &#8866; HDomain_Incl (Eats r (HPair d d&#39;)) (SUCC d)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>HDomain_Incl_Eats</span><span> </span><span>cut1</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;@{term HPair} is Provably Injective&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Doubleton_E</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insert (a EQ c) (insert (b EQ d) H) &#8866; A&quot;</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;insert (a EQ d) (insert (b EQ c) H) &#8866; A&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;insert ((Eats (Eats Zero b) a) EQ (Eats (Eats Zero d) c)) H &#8866; A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Equality_E</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>Zero_SubsetE</span><span> </span><span>rotate2</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a IN b&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span>rotate3</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>Zero_SubsetE</span><span> </span><span>rotate2</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a IN b&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Sym_L</span><span> </span><span>insert_commute</span><span> </span><span>thin1</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HFST</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{HPair a b EQ HPair c d} &#8866; a EQ c&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>HPair_def</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Assume</span><span> </span><span>Doubleton_E</span><span> </span><span>thin1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>b_EQ_d_1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{a EQ c, a EQ d, b EQ c} &#8866; b EQ d&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Assume</span><span> </span><span>thin1</span><span> </span><span>Sym</span><span> </span><span>Trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HSND</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{HPair a b EQ HPair c d} &#8866; b EQ d&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>HPair_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span>  </span><span>AssumeH</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Doubleton_E</span><span> </span><span>b_EQ_d_1</span><span> </span><span>rotate3</span><span> </span><span>thin2</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HPair_E</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insert (a EQ c) (insert (b EQ d) H) &#8866; A&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insert (HPair a b EQ HPair c d) H &#8866; A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Conj_E</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span>Conj_I</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>HFST</span><span> </span><span>HSND</span><span class="delimiter">]</span><span> </span><span>rcut1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>HPair_E</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate2</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>HPair_E</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate3</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>HPair_E</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate4</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>HPair_E</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate5</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>HPair_E</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate6</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>HPair_E</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate7</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>HPair_E</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate8</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HFun_Sigma_E</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; HFun_Sigma r&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; HPair a b IN r&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; HPair a b&#39; IN r&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; b EQ b&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>z</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x&#39;</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y&#39;</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>z&#39;</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>atoms</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom z &#9839; (r,a,b,b&#39;,z&#39;,x,y,x&#39;,y&#39;)&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;atom z&#39; &#9839; (r,a,b,b&#39;,x,y,x&#39;,y&#39;)&quot;</span></span></span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;atom x &#9839; (r,a,b,b&#39;,y,x&#39;,y&#39;)&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;atom y &#9839; (r,a,b,b&#39;,x&#39;,y&#39;)&quot;</span></span></span><span> 
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;atom x&#39; &#9839; (r,a,b,b&#39;,y&#39;)&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;atom y&#39; &#9839; (r,a,b,b&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>d1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; All2 z r (All2 z&#39; r (Ex x (Ex y (Ex x&#39; (Ex y&#39;
                  (Var z EQ HPair (Var x) (Var y) AND Var z&#39; EQ HPair (Var x&#39;) (Var y&#39;)
                   AND OrdP (Var x) AND OrdP (Var x&#39;) AND ((Var x EQ Var x&#39;) IMP (Var y EQ Var y&#39;))))))))&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>r</span><span> </span><span>HFun_Sigma.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>z</span><span> </span><span>r</span><span> </span><span>z&#39;</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>x&#39;</span><span> </span><span>y&#39;</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>d2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; All2 z&#39; r (Ex x (Ex y (Ex x&#39; (Ex y&#39;
             (HPair a b EQ HPair (Var x) (Var y) AND Var z&#39; EQ HPair (Var x&#39;) (Var y&#39;)
                   AND OrdP (Var x) AND OrdP (Var x&#39;) AND ((Var x EQ Var x&#39;) IMP (Var y EQ Var y&#39;)))))))&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>All_D</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;HPair a b&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>d1</span><span class="delimiter">]</span><span>  </span><span>atoms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>MP_same</span><span> </span><span>b</span><span class="delimiter">)</span><span>              
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>d4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; Ex x (Ex y (Ex x&#39; (Ex y&#39;
             (HPair a b EQ HPair (Var x) (Var y) AND HPair a b&#39; EQ HPair (Var x&#39;) (Var y&#39;)
               AND OrdP (Var x) AND OrdP (Var x&#39;) AND ((Var x EQ Var x&#39;) IMP (Var y EQ Var y&#39;))))))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>All_D</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;HPair a b&#39;&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>d2</span><span class="delimiter">]</span><span>  </span><span>atoms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>MP_same</span><span> </span><span>b&#39;</span><span class="delimiter">)</span><span>              
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>d&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{ Ex x (Ex y (Ex x&#39; (Ex y&#39;
             (HPair a b EQ HPair (Var x) (Var y) AND HPair a b&#39; EQ HPair (Var x&#39;) (Var y&#39;)
              AND OrdP (Var x) AND OrdP (Var x&#39;) AND ((Var x EQ Var x&#39;) IMP (Var y EQ Var y&#39;)))))) } &#8866; b EQ b&#39;&quot;</span></span></span><span> 
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>atoms</span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>ContraProve</span><span> </span><span>Trans</span><span> </span><span>Sym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cut_thin</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>d4</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;@{term SUCC} is Provably Injective&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SUCC_SUBS_lemma</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{SUCC x SUBS SUCC y} &#8866; x SUBS y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>obtain_fresh</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;(x,y)&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>SUCC_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Assume</span><span> </span><span>Conj_E1</span><span> </span><span>Extensionality</span><span> </span><span>Iff_MP_same</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>Subset_I</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Set_MP</span><span> </span><span>cut_same</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>Mem_cong</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>Refl</span><span> </span><span>Assume</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>Iff_MP2_same</span><span class="delimiter">]</span><span class="delimiter">]</span><span> 
</span><span>            </span><span>Mem_not_sym</span><span> </span><span>thin2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SUCC_SUBS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insert (SUCC x SUBS SUCC y) H &#8866; x SUBS y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Assume</span><span> </span><span>SUCC_SUBS_lemma</span><span> </span><span>cut1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SUCC_inject</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insert (SUCC x EQ SUCC y) H &#8866; x EQ y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Equality_I</span><span> </span><span>EQ_imp_SUBS</span><span> </span><span>SUCC_SUBS</span><span> </span><span>Sym_L</span><span> </span><span>cut1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SUCC_inject_E</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insert (x EQ y) H &#8866; A &#10233; insert (SUCC x EQ SUCC y) H &#8866; A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>SUCC_inject</span><span> </span><span>cut_same</span><span> </span><span>insert_commute</span><span> </span><span>thin1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>SUCC_inject_E</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate2</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>SUCC_inject_E</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate3</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>SUCC_inject_E</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate4</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>SUCC_inject_E</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate5</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>SUCC_inject_E</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate6</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>SUCC_inject_E</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate7</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>SUCC_inject_E</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate8</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdP_IN_SUCC_lemma</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{OrdP x, y IN x} &#8866; SUCC y IN SUCC x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>OrdP_linear</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SUCC x&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SUCC y&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>Mem_SUCC_EH</span><span>  </span><span>intro</span><span class="delimiter">:</span><span> </span><span>OrdP_SUCC_I</span><span> </span><span>Ord_IN_Ord0</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Hyp</span><span> </span><span>Mem_SUCC_I1</span><span> </span><span>Mem_not_sym</span><span> </span><span>cut_same</span><span> </span><span>insertCI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Assume</span><span> </span><span>EQ_imp_SUBS</span><span> </span><span>Mem_SUCC_I1</span><span> </span><span>Mem_non_refl</span><span> </span><span>Subset_D</span><span> </span><span>thin1</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>cut_same</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>Mem_cong</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>Iff_MP2_same</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdP_IN_SUCC</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; OrdP x &#10233; H &#8866; y IN x &#10233; H &#8866; SUCC y IN SUCC x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cut2</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>OrdP_IN_SUCC_lemma</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdP_IN_SUCC_D_lemma</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{OrdP x, SUCC y IN SUCC x} &#8866; y IN x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>OrdP_linear</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Assume</span><span> </span><span>AssumeH</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Mem_SUCC_Refl</span><span> </span><span>OrdP_SUCC_I</span><span> </span><span>Ord_IN_Ord</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Mem_SUCC_E</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rotate3</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Mem_SUCC_Refl</span><span> </span><span>OrdP_Trans</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>AssumeH</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>EQ_imp_SUBS</span><span> </span><span>Mem_SUCC_I1</span><span> </span><span>Mem_non_refl</span><span> </span><span>Subset_D</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>EQ_imp_SUBS</span><span> </span><span>Mem_SUCC_I2</span><span> </span><span>Mem_SUCC_EH</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Mem_SUCC_I1</span><span> </span><span>Refl</span><span> </span><span>SUCC_Subset_Ord_lemma</span><span> </span><span>Subset_D</span><span> </span><span>thin1</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdP_IN_SUCC_D</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; OrdP x &#10233; H &#8866; SUCC y IN SUCC x &#10233; H &#8866; y IN x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cut2</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>OrdP_IN_SUCC_D_lemma</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdP_IN_SUCC_Iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; OrdP y &#10233; H &#8866; SUCC x IN SUCC y IFF x IN y&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Assume</span><span> </span><span>Iff_I</span><span> </span><span>OrdP_IN_SUCC</span><span> </span><span>OrdP_IN_SUCC_D</span><span> </span><span>thin1</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The predicate &#8249;LstSeqP&#8250;&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hfun_sigma_ord_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hfun_sigma_ord s &#10231; OrdDom s &#8743; hfun_sigma s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hfun_sigma_ord_def</span><span> </span><span>OrdDom_def</span><span> </span><span>hfun_sigma_def</span><span> </span><span>HBall_def</span><span class="delimiter">,</span><span> </span><span>metis</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hfun_sigma_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hfun_sigma r &#10231; hfunction r &#8743; hrelation r&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>HBall_def</span><span> </span><span>hfun_sigma_def</span><span> </span><span>hfunction_def</span><span> </span><span>hrelation_def</span><span> </span><span>is_hpair_def</span><span class="delimiter">,</span><span> </span><span>metis</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Seq_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Seq r d &#10231; d &#8804; hdomain r &#8743; hfun_sigma r&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Seq_def</span><span> </span><span>hfun_sigma_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LstSeq_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;LstSeq s k y &#10231; succ k &#8804; hdomain s &#8743; &#10216;k,y&#10217; <span class="hidden">&#10073;</span><span class="bold">&#8712;</span> s &#8743; hfun_sigma_ord s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>OrdDom_def</span><span> </span><span>LstSeq_def</span><span> </span><span>Seq_iff</span><span> </span><span>hfun_sigma_ord_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>LstSeqP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; tm &#8658; tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;LstSeqP s k y = OrdP k AND HDomain_Incl s (SUCC k) AND HFun_Sigma s AND HPair k y IN s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>LstSeqP_graph_aux_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>LstSeqP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; LstSeqP s k y &#10231; a &#9839; s &#8743; a &#9839; k &#8743; a &#9839; y&quot;</span></span></span><span>         </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eval_fm_LstSeqP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;eval_fm e (LstSeqP s k y) &#10231; LstSeq &#10214;s&#10215;e &#10214;k&#10215;e &#10214;y&#10215;e&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thesis2</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>LstSeq_iff</span><span> </span><span>OrdDom_def</span><span> </span><span>hfun_sigma_ord_iff</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LstSeqP_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(LstSeqP s k y)(i::=t) = LstSeqP (subst i t s) (subst i t k) (subst i t y)&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fresh_Pair</span><span> </span><span>fresh_at_base</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LstSeqP_E</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insert (HDomain_Incl s (SUCC k)) 
            (insert (OrdP k) (insert (HFun_Sigma s)
              (insert (HPair k y IN s) H))) &#8866; B&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insert (LstSeqP s k y) H &#8866; B&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>insert_commute</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>LstSeqP.simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LstSeqP_cong</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; s EQ s&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; k EQ k&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; y EQ y&#39;&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; LstSeqP s k y IFF LstSeqP s&#39; k&#39; y&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>P3_cong</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>assms</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LstSeqP_OrdP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; LstSeqP r k y &#10233; H &#8866; OrdP k&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Conj_E1</span><span> </span><span>LstSeqP.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LstSeqP_Mem_lemma</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{ LstSeqP r k y, HPair k&#39; z IN r, k&#39; IN k } &#8866; LstSeqP r k&#39; z&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>LstSeqP.simps</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Ord_IN_Ord</span><span> </span><span>OrdP_SUCC_I</span><span> </span><span>OrdP_IN_SUCC</span><span> </span><span>HDomain_Incl_Mem_Ord</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LstSeqP_Mem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; LstSeqP r k y &#10233; H &#8866; HPair k&#39; z IN r &#10233; H &#8866; k&#39; IN k &#10233; H &#8866; LstSeqP r k&#39; z&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cut3</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>LstSeqP_Mem_lemma</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LstSeqP_imp_Mem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; LstSeqP s k y &#10233; H &#8866; HPair k y IN s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>LstSeqP.simps</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Conj_E2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LstSeqP_SUCC</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; LstSeqP r (SUCC d) y &#10233; H &#8866; HPair d z IN r &#10233; H &#8866; LstSeqP r d z&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>LstSeqP_Mem</span><span> </span><span>Mem_SUCC_I2</span><span> </span><span>Refl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LstSeqP_EQ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;H &#8866; LstSeqP s k y; H &#8866; HPair k y&#39; IN s&#10215; &#10233; H &#8866; y EQ y&#39;&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>AssumeH</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>HFun_Sigma_E</span><span> </span><span>LstSeqP_E</span><span> </span><span>cut1</span><span> </span><span>insert_commute</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>

</div>
</body>
</html>
