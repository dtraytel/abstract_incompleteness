<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Coding_Predicates (Isabelle2020-RC3: March 2020)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Coding_Predicates</h1>

<span class="command">theory</span> <span class="name">Coding_Predicates</span><br/>
<span class="keyword">imports</span> <a href="Coding.html"><span class="name">Coding</span></a> <a href="Sigma.html"><span class="name">Sigma</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">chapter</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Predicates for Terms, Formulas and Substitution&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Coding_Predicates</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Coding</span><span> </span><span>Sigma</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>succ_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;This material comes from Section 3, greatly modified for de Bruijn syntax.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Predicates for atomic terms&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Free Variables&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_Var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hf &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Var x &#8801; Ord x &#8743; 0 <span class="hidden">&#10073;</span><span class="bold">&#8712;</span> x&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>VarP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; fm&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;VarP x &#8801; OrdP x AND Zero IN x&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>VarP_eqvt</span><span> </span><span class="delimiter">[</span><span>eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(p &#8729; VarP x) = VarP (p &#8729; x)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>VarP_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>VarP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; VarP x &#10231; a &#9839; x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>VarP_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eval_fm_VarP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;eval_fm e (VarP x) &#10231; is_Var &#10214;x&#10215;e&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>VarP_def</span><span> </span><span>is_Var_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>VarP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (VarP x)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>VarP_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>VarP_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(VarP x)(i::=t) = VarP (subst i t x) &quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>VarP_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>VarP_cong</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; x EQ x&#39; &#10233; H &#8866; VarP x IFF VarP x&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>P1_cong</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>VarP_HPairE</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insert (VarP (HPair x y)) H &#8866; A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>VarP_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_Var_succ_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Var (succ x) = Ord x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_succ_iff</span><span> </span><span>is_Var_def</span><span> </span><span>succ_iff</span><span> </span><span>zero_in_Ord</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_Var_q_Var</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Var (q_Var i)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>q_Var_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>decode_Var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hf &#8658; name&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;decode_Var x &#8801; name_of_nat (nat_of_ord (pred x))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>decode_Var_q_Var</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;decode_Var (q_Var i) = i&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>decode_Var_def</span><span> </span><span>q_Var_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_Var_imp_decode_Var</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Var x &#10233; x = &#10214;&#171;Var (decode_Var x)&#187;&#10215; e&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_Var_def</span><span> </span><span>quot_Var</span><span> </span><span>decode_Var_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hempty_iff</span><span> </span><span>succ_pred</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_Var_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Var v &#10231; v = succ (ord_of (nat_of_name (decode_Var v)))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>eval_tm_ORD_OF</span><span> </span><span>eval_tm_SUCC</span><span> </span><span>is_Var_imp_decode_Var</span><span> </span><span>quot_Var</span><span> </span><span>is_Var_succ_iff</span><span> </span><span>Ord_ord_of</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>decode_Var_inject</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Var v &#10233; is_Var v&#39; &#10233; decode_Var v = decode_Var v&#39; &#10231; v=v&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>is_Var_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;De Bruijn Indexes&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_Ind</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hf &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Ind x &#8801; (&#8707;m. Ord m &#8743; x = &#10216;htuple 6, m&#10217;)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>Q_Ind</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; tm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Q_Ind k &#8801; HPair (HTuple 6) k&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>IndP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom m &#9839; x &#10233;
    IndP x = Ex m (OrdP (Var m) AND x EQ HPair (HTuple 6) (Var m))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>IndP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>IndP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; IndP x &#10231; a &#9839; x&quot;</span></span></span><span>                </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eval_fm_IndP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;eval_fm e (IndP x) &#10231; is_Ind &#10214;x&#10215;e&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>IndP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (IndP x)&quot;</span></span></span><span>                   </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thsf</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>OrdP_IndP_Q_Ind</span><span class="delimiter">:</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;{OrdP x} &#8866; IndP (Q_Ind x)&quot;</span></span></span><span>           </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thqind</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom m &#9839; x&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thesis2</span><span> </span><span class="var">?thsf</span><span> </span><span class="var">?thqind</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_Ind_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Ex_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>IndP_Q_Ind</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; OrdP x &#10233; H &#8866; IndP (Q_Ind x)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cut1</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>OrdP_IndP_Q_Ind</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subst_fm_IndP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(IndP t)(i::=x) = IndP (subst i x t)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom m &#9839; (i,t,x)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>IndP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>IndP_cong</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; x EQ x&#39; &#10233; H &#8866; IndP x IFF IndP x&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>P1_cong</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>decode_Ind</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hf &#8658; nat&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;decode_Ind x &#8801; nat_of_ord (hsnd x)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_Ind_pair_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Ind &#10216;x, y&#10217; &#10231; x = htuple 6 &#8743; Ord y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_Ind_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Various syntactic lemmas&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eval_Var_q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#171;Var i&#187;&#10215; e = q_Var i&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>quot_tm_def</span><span> </span><span>q_Var_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_Var_eval_Var</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Var &#10214;&#171;Var i&#187;&#10215;e&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>decode_Var_q_Var</span><span> </span><span>is_Var_imp_decode_Var</span><span> </span><span>is_Var_q_Var</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The predicate &#8249;SeqCTermP&#8250;, for Terms and Constants&#8250;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*SeqCTerm(s,k,t) &#8801; LstSeq(s,k,t) &#8743; (&#8704;l&#8712;k)[s l=0 &#8744; Var(s l)&#8744;(&#8707;m,n&#8712;l)[s l = &#10216;Eats, s m, s n&#10217;]]*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>SeqCTerm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bool &#8658; hf &#8658; hf &#8658; hf &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SeqCTerm vf s k t &#8801; BuildSeq (&#955;u. u=0 &#8744; vf &#8743; is_Var u) (&#955;u v w. u = q_Eats v w) s k t&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>SeqCTermP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bool &#8658; tm &#8658; tm &#8658; tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom l &#9839; (s,k,sl,m,n,sm,sn);  atom sl &#9839; (s,m,n,sm,sn);
          atom m &#9839; (s,n,sm,sn);  atom n &#9839; (s,sm,sn);
          atom sm &#9839; (s,sn);  atom sn &#9839; (s)&#10215; &#10233;
    SeqCTermP vf s k t =
      LstSeqP s k t AND
      All2 l (SUCC k) (Ex sl (HPair (Var l) (Var sl) IN s AND 
               (Var sl EQ Zero OR (if vf then VarP (Var sl) else Fls) OR
                Ex m (Ex n (Ex sm (Ex sn (Var m IN Var l AND Var n IN Var l AND
                       HPair (Var m) (Var sm) IN s AND HPair (Var n) (Var sn) IN s AND
                       Var sl EQ Q_Eats (Var sm) (Var sn))))))))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>SeqCTermP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>SeqCTermP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; SeqCTermP vf s k t &#10231; a &#9839; s &#8743; a &#9839; k &#8743; a &#9839; t&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eval_fm_SeqCTermP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;eval_fm e (SeqCTermP vf s k t) &#10231; SeqCTerm vf &#10214;s&#10215;e &#10214;k&#10215;e &#10214;t&#10215;e&quot;</span></span></span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SeqCTermP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (SeqCTermP vf s k t)&quot;</span></span></span><span>   </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thsf</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SeqCTermP_imp_LstSeqP</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;{ SeqCTermP vf s k t } &#8866; LstSeqP s k t&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thlstseq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SeqCTermP_imp_OrdP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;{ SeqCTermP vf s k t } &#8866; OrdP k&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thord</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sm</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sn</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>atoms</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom l &#9839; (s,k,sl,m,n,sm,sn)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom sl &#9839; (s,m,n,sm,sn)&quot;</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;atom m &#9839; (s,n,sm,sn)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom n &#9839; (s,sm,sn)&quot;</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;atom sm &#9839; (s,sn)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom sn &#9839; (s)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thsf</span><span> </span><span class="var">?thlstseq</span><span> </span><span class="var">?thord</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>LstSeqP.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis2</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>atoms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>conj_cong</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>LstSeq_imp_Ord</span><span> </span><span>SeqCTerm_def</span><span> </span><span>BuildSeq_def</span><span> </span><span>Builds_def</span><span>
</span><span>             </span><span>HBall_def</span><span> </span><span>HBex_def</span><span> </span><span>q_Eats_def</span><span> </span><span>Fls_def</span><span>
</span><span>             </span><span>Seq_iff_app</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;s&#10215;e&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>LstSeq_imp_Seq_succ</span><span class="delimiter">]</span><span>
</span><span>             </span><span>Ord_trans</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;succ &#10214;k&#10215;e&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SeqCTermP_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;(SeqCTermP vf s k t)(j::=w) = SeqCTermP vf (subst j w s) (subst j w k) (subst j w t)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sm</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sn</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom l &#9839; (j,w,s,k,sl,m,n,sm,sn)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom sl &#9839; (j,w,s,m,n,sm,sn)&quot;</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;atom m &#9839; (j,w,s,n,sm,sn)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom n &#9839; (j,w,s,sm,sn)&quot;</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;atom sm &#9839; (j,w,s,sn)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom sn &#9839; (j,w,s)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>SeqCTermP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>l</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>sl</span><span> </span><span>m</span><span> </span><span>n</span><span> </span><span>sm</span><span> </span><span>sn</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>SeqCTermP.simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>SeqTerm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hf &#8658; hf &#8658; hf &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SeqTerm &#8801; SeqCTerm True&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>SeqTermP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; tm &#8658; tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SeqTermP &#8801; SeqCTermP True&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>SeqConst</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hf &#8658; hf &#8658; hf &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SeqConst &#8801; SeqCTerm False&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>SeqConstP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; tm &#8658; tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SeqConstP &#8801; SeqCTermP False&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SeqConst_imp_SeqTerm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SeqConst s k x &#10233; SeqTerm s k x&quot;</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>SeqCTerm_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>BuildSeq_mono</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SeqConstP_imp_SeqTermP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{SeqConstP s k t} &#8866; SeqTermP s k t&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sm</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sn</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom l &#9839; (s,k,t,sl,m,n,sm,sn)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom sl &#9839; (s,k,t,m,n,sm,sn)&quot;</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;atom m &#9839; (s,k,t,n,sm,sn)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom n &#9839; (s,k,t,sm,sn)&quot;</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;atom sm &#9839; (s,k,t,sn)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom sn &#9839; (s,k,t)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>SeqCTermP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>l</span><span> </span><span>s</span><span> </span><span>k</span><span> </span><span>sl</span><span> </span><span>m</span><span> </span><span>n</span><span> </span><span>sm</span><span> </span><span>sn</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ex_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;Var l&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ex_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Var sl&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>force</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Disj_I1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ex_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Var sl&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Conj_I</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Disj_I2</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ex_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Var m&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ex_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Var n&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ex_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Var sm&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ex_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Var sn&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The predicates &#8249;TermP&#8250; and &#8249;ConstP&#8250;&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Definition&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>CTerm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bool &#8658; hf &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;CTerm vf t &#8801; (&#8707;s k. SeqCTerm vf s k t)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>CTermP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bool &#8658; tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom k &#9839; (s,t); atom s &#9839; t&#10215; &#10233;
    CTermP vf t = Ex s (Ex k (SeqCTermP vf (Var s) (Var k) t))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>CTermP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>CTermP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; CTermP vf t &#10231; a &#9839; t&quot;</span></span></span><span>            </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eval_fm_CTermP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;eval_fm e (CTermP vf t) &#10231; CTerm vf &#10214;t&#10215;e&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>CTermP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (CTermP vf t)&quot;</span></span></span><span>                      </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thsf</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>k</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span class="delimiter">::</span><span>name</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom k &#9839; (s,t)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom s &#9839; t&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thesis2</span><span> </span><span class="var">?thsf</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>CTerm_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>CTermP_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(CTermP vf i)(j::=w) = CTermP vf (subst j w i)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>k</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span class="delimiter">::</span><span>name</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom k &#9839; (s,i,j,w)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom s &#9839; (i,j,w)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CTermP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>k</span><span> </span><span>s</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>Term</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hf &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Term &#8801; CTerm True&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>TermP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TermP &#8801; CTermP True&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>Const</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hf &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Const &#8801; CTerm False&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>ConstP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ConstP &#8801; CTermP False&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Correctness: It Corresponds to Quotations of Real Terms&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_Term_quot_dbtm</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_dbtm u &#10233; Term &#10214;quot_dbtm u&#10215;e&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>wf_dbtm.induct</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>CTerm_def</span><span> </span><span>SeqCTerm_def</span><span> </span><span>q_Eats_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>BuildSeq_combine</span><span> </span><span>BuildSeq_exI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>Term_quot_tm</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>t</span><span> </span><span class="delimiter">::</span><span> </span><span>tm</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Term &#10214;&#171;t&#187;&#10215;e&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>quot_tm_def</span><span> </span><span>wf_Term_quot_dbtm</span><span> </span><span>wf_dbtm_trans_tm</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SeqCTerm_imp_wf_dbtm</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SeqCTerm vf s k x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;t::dbtm. wf_dbtm t &#8743; x = &#10214;quot_dbtm t&#10215;e&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>SeqCTerm_def</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>x</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>BuildSeq_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>B</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ORD_OF.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Var</span><span> </span><span>quot_dbtm.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>is_Var_imp_decode_Var</span><span> </span><span>quot_Var</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>C</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>tm1</span><span class="delimiter">::</span><span>dbtm</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tm2</span><span class="delimiter">::</span><span>dbtm</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_dbtm tm1&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y = &#10214;quot_dbtm tm1&#10215;e&quot;</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;wf_dbtm tm2&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;z = &#10214;quot_dbtm tm2&#10215;e&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wf_dbtm.intros</span><span> </span><span>C</span><span> </span><span>q_Eats_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;DBEats tm1 tm2&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>Term_imp_wf_dbtm</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Term x&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_dbtm t&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x = &#10214;quot_dbtm t&#10215;e&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>SeqCTerm_imp_wf_dbtm</span><span> </span><span>CTerm_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>Term_imp_is_tm</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Term x&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>t</span><span class="delimiter">::</span><span>tm</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x = &#10214;&#171;t&#187;&#10215; e&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>Term_imp_wf_dbtm</span><span> </span><span>quot_tm_def</span><span> </span><span>wf_dbtm_imp_is_tm</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Term_Var</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Term (q_Var i)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_Term_quot_dbtm</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;DBVar i&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Term_quot_tm</span><span> </span><span>is_Var_imp_decode_Var</span><span> </span><span>is_Var_q_Var</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Term_Eats</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Term x&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Term y&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Term (q_Eats x y)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t</span><span> </span><span>u</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x = &#10214;quot_dbtm t&#10215;e&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y = &#10214;quot_dbtm u&#10215;e&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Term_imp_wf_dbtm</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_Term_quot_dbtm</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;DBEats t u&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>q_defs</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Eats</span><span> </span><span>Term_imp_wf_dbtm</span><span> </span><span>quot_dbtm_inject_lemma</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Correctness properties for constants&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Const_imp_Term</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Const x &#10233; Term x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>SeqConst_imp_SeqTerm</span><span> </span><span>CTerm_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Const_0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Const 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CTerm_def</span><span> </span><span>SeqCTerm_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>BuildSeq_exI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ConstP_imp_TermP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{ConstP t} &#8866; TermP t&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>k</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span class="delimiter">::</span><span>name</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom k &#9839; (s,t)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom s &#9839; t&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ex_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Var s&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ex_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Var k&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>SeqConstP_imp_SeqTermP</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>cut1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Abstraction over terms&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>SeqStTerm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hf &#8658; hf &#8658; hf &#8658; hf &#8658; hf &#8658; hf &#8658; bool&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SeqStTerm v u x x&#39; s k &#8801;
       is_Var v &#8743; BuildSeq2 (&#955;y y&#39;. (is_Ind y &#8744; Ord y) &#8743; y&#39; = (if y=v then u else y))
                (&#955;u u&#39; v v&#39; w w&#39;. u = q_Eats v w &#8743; u&#39; = q_Eats v&#39; w&#39;) s k x x&#39;&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>AbstTerm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hf &#8658; hf &#8658; hf &#8658; hf &#8658; bool&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;AbstTerm v i x x&#39; &#8801; Ord i &#8743; (&#8707;s k. SeqStTerm v (q_Ind i) x x&#39; s k)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Defining the syntax: quantified body&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>SeqStTermP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; tm &#8658; tm &#8658; tm &#8658; tm &#8658; tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom l &#9839; (s,k,v,i,sl,sl&#39;,m,n,sm,sm&#39;,sn,sn&#39;);
          atom sl &#9839; (s,v,i,sl&#39;,m,n,sm,sm&#39;,sn,sn&#39;); atom sl&#39; &#9839; (s,v,i,m,n,sm,sm&#39;,sn,sn&#39;);
          atom m &#9839; (s,n,sm,sm&#39;,sn,sn&#39;); atom n &#9839; (s,sm,sm&#39;,sn,sn&#39;);
          atom sm &#9839; (s,sm&#39;,sn,sn&#39;); atom sm&#39; &#9839; (s,sn,sn&#39;);
          atom sn &#9839; (s,sn&#39;); atom sn&#39; &#9839; s&#10215; &#10233;
    SeqStTermP v i t u s k =
      VarP v AND LstSeqP s k (HPair t u) AND
      All2 l (SUCC k) (Ex sl (Ex sl&#39; (HPair (Var l) (HPair (Var sl) (Var sl&#39;)) IN s AND
                (((Var sl EQ v AND Var sl&#39; EQ i) OR
                  ((IndP (Var sl) OR Var sl NEQ v) AND Var sl&#39; EQ Var sl)) OR
                Ex m (Ex n (Ex sm (Ex sm&#39; (Ex sn (Ex sn&#39; (Var m IN Var l AND Var n IN Var l AND
                       HPair (Var m) (HPair (Var sm) (Var sm&#39;)) IN s AND
                       HPair (Var n) (HPair (Var sn) (Var sn&#39;)) IN s AND
                       Var sl EQ Q_Eats (Var sm) (Var sn) AND
                       Var sl&#39; EQ Q_Eats (Var sm&#39;) (Var sn&#39;)))))))))))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>SeqStTermP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>SeqStTermP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; SeqStTermP v i t u s k &#10231; a &#9839; v &#8743; a &#9839; i &#8743; a &#9839; t &#8743; a &#9839; u &#8743; a &#9839; s &#8743; a &#9839; k&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eval_fm_SeqStTermP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;eval_fm e (SeqStTermP v i t u s k) &#10231; SeqStTerm &#10214;v&#10215;e &#10214;i&#10215;e &#10214;t&#10215;e &#10214;u&#10215;e &#10214;s&#10215;e &#10214;k&#10215;e&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SeqStTermP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (SeqStTermP v i t u s k)&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thsf</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SeqStTermP_imp_OrdP</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;{ SeqStTermP v i t u s k } &#8866; OrdP k&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thord</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SeqStTermP_imp_VarP</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;{ SeqStTermP v i t u s k } &#8866; VarP v&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thvar</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SeqStTermP_imp_LstSeqP</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;{ SeqStTermP v i t u s k } &#8866; LstSeqP s k (HPair t u)&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thlstseq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl&#39;</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>sm</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sm&#39;</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sn</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sn&#39;</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>atoms</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;atom l &#9839; (s,k,v,i,sl,sl&#39;,m,n,sm,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;atom sl &#9839; (s,v,i,sl&#39;,m,n,sm,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom sl&#39; &#9839; (s,v,i,m,n,sm,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;atom m &#9839; (s,n,sm,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom n &#9839; (s,sm,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;atom sm &#9839; (s,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom sm&#39; &#9839; (s,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;atom sn &#9839; (s,sn&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom sn&#39; &#9839; (s)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thsf</span><span> </span><span class="var">?thord</span><span> </span><span class="var">?thvar</span><span> </span><span class="var">?thlstseq</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>LstSeqP_OrdP</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis2</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>atoms</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>LstSeq_imp_Ord</span><span> </span><span>SeqStTerm_def</span><span> </span><span>ex_disj_distrib</span><span>
</span><span>             </span><span>BuildSeq2_def</span><span> </span><span>BuildSeq_def</span><span> </span><span>Builds_def</span><span>
</span><span>             </span><span>HBall_def</span><span> </span><span>q_Eats_def</span><span> </span><span>q_Ind_def</span><span> </span><span>is_Var_def</span><span>
</span><span>             </span><span>Seq_iff_app</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;s&#10215;e&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>LstSeq_imp_Seq_succ</span><span class="delimiter">]</span><span>
</span><span>             </span><span>Ord_trans</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;succ &#10214;k&#10215;e&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>             </span><span>cong</span><span class="delimiter">:</span><span> </span><span>conj_cong</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conj_cong</span><span> </span><span>refl</span><span> </span><span>all_cong</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Not_Ord_hpair</span><span> </span><span>is_Ind_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SeqStTermP_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;(SeqStTermP v i t u s k)(j::=w) =
       SeqStTermP (subst j w v) (subst j w i) (subst j w t) (subst j w u) (subst j w s) (subst j w k)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl&#39;</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>sm</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sm&#39;</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sn</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sn&#39;</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom l &#9839; (s,k,v,i,w,j,sl,sl&#39;,m,n,sm,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sl &#9839; (s,v,i,w,j,sl&#39;,m,n,sm,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sl&#39; &#9839; (s,v,i,w,j,m,n,sm,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom m &#9839; (s,w,j,n,sm,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom n &#9839; (s,w,j,sm,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sm &#9839; (s,w,j,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom sm&#39; &#9839; (s,w,j,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sn &#9839; (s,w,j,sn&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom sn&#39; &#9839; (s,w,j)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>SeqStTermP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>l</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>sl</span><span> </span><span>sl&#39;</span><span> </span><span>m</span><span> </span><span>n</span><span> </span><span>sm</span><span> </span><span>sm&#39;</span><span> </span><span>sn</span><span> </span><span>sn&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SeqStTermP_cong</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;H &#8866; t EQ t&#39;; H &#8866; u EQ u&#39;; H &#8866; s EQ s&#39;; H &#8866; k EQ k&#39;&#10215;
   &#10233; H &#8866; SeqStTermP v i t u s k IFF SeqStTermP v i t&#39; u&#39; s&#39; k&#39;&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>P4_cong</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>tms</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;[v,i]&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fresh_Cons</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>SeqStTermP.simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Defining the syntax: main predicate&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>AbstTermP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; tm &#8658; tm &#8658; tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom s &#9839; (v,i,t,u,k); atom k &#9839; (v,i,t,u)&#10215; &#10233;
    AbstTermP v i t u =
     OrdP i AND Ex s (Ex k (SeqStTermP v (Q_Ind i) t u (Var s) (Var k)))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>AbstTermP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>AbstTermP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; AbstTermP v i t u &#10231; a &#9839; v &#8743; a &#9839; i &#8743; a &#9839; t &#8743; a &#9839; u&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eval_fm_AbstTermP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;eval_fm e (AbstTermP v i t u) &#10231; AbstTerm &#10214;v&#10215;e &#10214;i&#10215;e &#10214;t&#10215;e &#10214;u&#10215;e &quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>AbstTermP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (AbstTermP v i t u)&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thsf</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>k</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom s &#9839; (v,i,t,u,k)&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;atom k &#9839; (v,i,t,u)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thesis2</span><span> </span><span class="var">?thsf</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>AbstTerm_def</span><span> </span><span>q_defs</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>AbstTermP_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;(AbstTermP v i t u)(j::=w) = AbstTermP (subst j w v) (subst j w i) (subst j w t) (subst j w u)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>k</span><span class="delimiter">::</span><span>name</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom s &#9839; (v,i,t,u,w,j,k)&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;atom k &#9839; (v,i,t,u,w,j)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>AbstTermP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>k</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>AbstTermP.simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Correctness: It Coincides with Abstraction over real terms&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_is_Var_is_Ind</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Var v &#10233; &#172; is_Ind v&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_Var_def</span><span> </span><span>is_Ind_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>AbstTerm_imp_abst_dbtm</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;AbstTerm v i x x&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;t. x = &#10214;quot_dbtm t&#10215;e &#8743;
             x&#39; = &#10214;quot_dbtm (abst_dbtm (decode_Var v) (nat_of_ord i) t)&#10215;e&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span> </span><span>k</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>v</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Var v&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Ord i&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sk</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SeqStTerm v (q_Ind i) x x&#39; s k&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>AbstTerm_def</span><span> </span><span>SeqStTerm_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>sk</span><span> </span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>SeqStTerm_def</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>conjunct2</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>x</span><span> </span><span>x&#39;</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>BuildSeq2_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>B</span><span> </span><span>x</span><span> </span><span>x&#39;</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>v</span><span> </span><span>i</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>not_is_Var_is_Ind</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;DBInd (nat_of_ord (hsnd x))&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;DBVar (decode_Var v)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span>3</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Var x&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span class="delimiter">[</span><span>3</span><span class="delimiter">]</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;DBVar (decode_Var x)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span class="delimiter">[</span><span>4</span><span class="delimiter">]</span><span> </span><span>x</span><span class="delimiter">=</span><span>DBZero</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_Ind_def</span><span> </span><span>q_Ind_def</span><span> </span><span>is_Var_iff</span><span> </span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hmem_0_Ord</span><span> </span><span>is_Var_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>C</span><span> </span><span>x</span><span> </span><span>x&#39;</span><span> </span><span>y</span><span> </span><span>y&#39;</span><span> </span><span>z</span><span> </span><span>z&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>tm1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tm2</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y = &#10214;quot_dbtm tm1&#10215;e&quot;</span></span></span><span>
</span><span>              </span><span class="string"><span class="delete"><span class="delete">&quot;y&#39; = &#10214;quot_dbtm (abst_dbtm (decode_Var v) (nat_of_ord i) tm1)&#10215;e&quot;</span></span></span><span>
</span><span>            </span><span class="string"><span class="delete"><span class="delete">&quot;z = &#10214;quot_dbtm tm2&#10215;e&quot;</span></span></span><span>
</span><span>              </span><span class="string"><span class="delete"><span class="delete">&quot;z&#39; = &#10214;quot_dbtm (abst_dbtm (decode_Var v) (nat_of_ord i) tm2)&#10215;e&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wf_dbtm.intros</span><span> </span><span>C</span><span> </span><span>q_Eats_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;DBEats tm1 tm2&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>AbstTerm_abst_dbtm</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;AbstTerm (q_Var i) (ord_of n) &#10214;quot_dbtm t&#10215;e
                                    &#10214;quot_dbtm (abst_dbtm i n t)&#10215;e&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>dbtm.induct</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>AbstTerm_def</span><span> </span><span>SeqStTerm_def</span><span> </span><span>q_defs</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>BuildSeq2_exI</span><span> </span><span>BuildSeq2_combine</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Substitution over terms&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>SubstTerm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hf &#8658; hf &#8658; hf &#8658; hf &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SubstTerm v u x x&#39; &#8801; Term u &#8743; (&#8707;s k. SeqStTerm v u x x&#39; s k)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Defining the syntax&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>SubstTermP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; tm &#8658; tm &#8658; tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom s &#9839; (v,i,t,u,k); atom k &#9839; (v,i,t,u)&#10215; &#10233;
    SubstTermP v i t u = TermP i AND Ex s (Ex k (SeqStTermP v i t u (Var s) (Var k)))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>SubstTermP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>SubstTermP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; SubstTermP v i t u &#10231; a &#9839; v &#8743; a &#9839; i &#8743; a &#9839; t &#8743; a &#9839; u&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eval_fm_SubstTermP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;eval_fm e (SubstTermP v i t u) &#10231; SubstTerm &#10214;v&#10215;e &#10214;i&#10215;e &#10214;t&#10215;e &#10214;u&#10215;e&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SubstTermP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (SubstTermP v i t u)&quot;</span></span></span><span>     </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thsf</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SubstTermP_imp_TermP</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;{ SubstTermP v i t u } &#8866; TermP i&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thterm</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SubstTermP_imp_VarP</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;{ SubstTermP v i t u } &#8866; VarP v&quot;</span></span></span><span>   </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thvar</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>k</span><span class="delimiter">::</span><span>name</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom s &#9839; (v,i,t,u,k)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom k &#9839; (v,i,t,u)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thesis2</span><span> </span><span class="var">?thsf</span><span> </span><span class="var">?thterm</span><span> </span><span class="var">?thvar</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>SubstTerm_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>SeqStTermP_imp_VarP</span><span> </span><span>thin2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SubstTermP_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;(SubstTermP v i t u)(j::=w) = SubstTermP (subst j w v) (subst j w i) (subst j w t) (subst j w u)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>k</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom s &#9839; (v,i,t,u,w,j,k)&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;atom k &#9839; (v,i,t,u,w,j)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>SubstTermP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>k</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SubstTermP_cong</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;H &#8866; v EQ v&#39;; H &#8866; i EQ i&#39;; H &#8866; t EQ t&#39;; H &#8866; u EQ u&#39;&#10215;
   &#10233; H &#8866; SubstTermP v i t u IFF SubstTermP v&#39; i&#39; t&#39; u&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>P4_cong</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>SubstTermP.simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SubstTerm_imp_subst_dbtm</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SubstTerm v &#10214;quot_dbtm u&#10215;e x x&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;t. x = &#10214;quot_dbtm t&#10215;e &#8743;
             x&#39; = &#10214;quot_dbtm (subst_dbtm u (decode_Var v) t)&#10215;e&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span> </span><span>k</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>v</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Var v&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Term &#10214;quot_dbtm u&#10215;e&quot;</span></span></span><span>
</span><span>               </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sk</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SeqStTerm v &#10214;quot_dbtm u&#10215;e x x&#39; s k&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>SubstTerm_def</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>SeqStTerm_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>sk</span><span> </span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>SeqStTerm_def</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>conjunct2</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>x</span><span> </span><span>x&#39;</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>BuildSeq2_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>B</span><span> </span><span>x</span><span> </span><span>x&#39;</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>v</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>not_is_Var_is_Ind</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;DBInd (nat_of_ord (hsnd x))&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;DBVar (decode_Var v)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span>3</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Var x&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span class="delimiter">[</span><span>3</span><span class="delimiter">]</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;DBVar (decode_Var x)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span class="delimiter">[</span><span>4</span><span class="delimiter">]</span><span> </span><span>x</span><span class="delimiter">=</span><span>DBZero</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_Ind_def</span><span> </span><span>q_Ind_def</span><span> </span><span>is_Var_iff</span><span> </span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hmem_0_Ord</span><span> </span><span>is_Var_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>C</span><span> </span><span>x</span><span> </span><span>x&#39;</span><span> </span><span>y</span><span> </span><span>y&#39;</span><span> </span><span>z</span><span> </span><span>z&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>tm1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tm2</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y = &#10214;quot_dbtm tm1&#10215;e&quot;</span></span></span><span>
</span><span>              </span><span class="string"><span class="delete"><span class="delete">&quot;y&#39; = &#10214;quot_dbtm (subst_dbtm u (decode_Var v) tm1)&#10215;e&quot;</span></span></span><span>
</span><span>            </span><span class="string"><span class="delete"><span class="delete">&quot;z = &#10214;quot_dbtm tm2&#10215;e&quot;</span></span></span><span>
</span><span>              </span><span class="string"><span class="delete"><span class="delete">&quot;z&#39; = &#10214;quot_dbtm (subst_dbtm u (decode_Var v) tm2)&#10215;e&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wf_dbtm.intros</span><span> </span><span>C</span><span> </span><span>q_Eats_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;DBEats tm1 tm2&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>SubstTerm_imp_subst_dbtm&#39;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SubstTerm v y x x&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>t</span><span class="delimiter">::</span><span>dbtm</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>u</span><span class="delimiter">::</span><span>dbtm</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y = &#10214;quot_dbtm u&#10215;e&quot;</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;x = &#10214;quot_dbtm t&#10215;e&quot;</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;x&#39; = &#10214;quot_dbtm (subst_dbtm u (decode_Var v) t)&#10215;e&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>SubstTerm_def</span><span> </span><span>SubstTerm_imp_subst_dbtm</span><span> </span><span>Term_imp_is_tm</span><span> </span><span>assms</span><span> </span><span>quot_tm_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SubstTerm_subst_dbtm</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Term &#10214;quot_dbtm u&#10215;e&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SubstTerm (q_Var v) &#10214;quot_dbtm u&#10215;e &#10214;quot_dbtm t&#10215;e &#10214;quot_dbtm (subst_dbtm u v t)&#10215;e&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>dbtm.induct</span><span class="delimiter">)</span><span> 
</span><span>     </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>SubstTerm_def</span><span> </span><span>SeqStTerm_def</span><span> </span><span>q_defs</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>BuildSeq2_exI</span><span> </span><span>BuildSeq2_combine</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Abstraction over formulas&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The predicate &#8249;AbstAtomicP&#8250;&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>AbstAtomic</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hf &#8658; hf &#8658; hf &#8658; hf &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;AbstAtomic v i y y&#39; &#8801; 
            (&#8707;t u t&#39; u&#39;. AbstTerm v i t t&#39; &#8743; AbstTerm v i u u&#39; &#8743;
             ((y = q_Eq t u &#8743; y&#39; = q_Eq t&#39; u&#39;) &#8744; (y = q_Mem t u &#8743; y&#39; = q_Mem t&#39; u&#39;)))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>AbstAtomicP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; tm &#8658; tm &#8658; tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom t &#9839; (v,i,y,y&#39;,t&#39;,u,u&#39;); atom t&#39; &#9839; (v,i,y,y&#39;,u,u&#39;);
          atom u &#9839; (v,i,y,y&#39;,u&#39;); atom u&#39; &#9839; (v,i,y,y&#39;)&#10215; &#10233;
    AbstAtomicP v i y y&#39; =
         Ex t (Ex u (Ex t&#39; (Ex u&#39;
           (AbstTermP v i (Var t) (Var t&#39;) AND AbstTermP v i (Var u) (Var u&#39;) AND
                      ((y EQ Q_Eq (Var t) (Var u) AND y&#39; EQ Q_Eq (Var t&#39;) (Var u&#39;)) OR
                       (y EQ Q_Mem (Var t) (Var u) AND y&#39; EQ Q_Mem (Var t&#39;) (Var u&#39;)))))))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>AbstAtomicP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>AbstAtomicP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; AbstAtomicP v i y y&#39; &#10231; a &#9839; v &#8743; a &#9839; i &#8743; a &#9839; y &#8743; a &#9839; y&#39;&quot;</span></span></span><span>         </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eval_fm_AbstAtomicP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;eval_fm e (AbstAtomicP v i y y&#39;) &#10231; AbstAtomic &#10214;v&#10215;e &#10214;i&#10215;e &#10214;y&#10215;e &#10214;y&#39;&#10215;e&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>AbstAtomicP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (AbstAtomicP v i y y&#39;)&quot;</span></span></span><span>              </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thsf</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>u</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t&#39;</span><span class="delimiter">::</span><span>name</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>u&#39;</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom t &#9839; (v,i,y,y&#39;,t&#39;,u,u&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom t&#39; &#9839; (v,i,y,y&#39;,u,u&#39;)&quot;</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;atom u &#9839; (v,i,y,y&#39;,u&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom u&#39; &#9839; (v,i,y,y&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thesis2</span><span> </span><span class="var">?thsf</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>AbstAtomic_def</span><span> </span><span>q_defs</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>AbstAtomicP_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;(AbstAtomicP v tm y y&#39;)(i::=w) = AbstAtomicP (subst i w v) (subst i w tm) (subst i w y) (subst i w y&#39;)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>u</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t&#39;</span><span class="delimiter">::</span><span>name</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>u&#39;</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom t &#9839; (v,tm,y,y&#39;,w,i,t&#39;,u,u&#39;)&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;atom t&#39; &#9839; (v,tm,y,y&#39;,w,i,u,u&#39;)&quot;</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;atom u &#9839; (v,tm,y,y&#39;,w,i,u&#39;)&quot;</span></span></span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;atom u&#39; &#9839; (v,tm,y,y&#39;,w,i)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>AbstAtomicP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>t</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>t&#39;</span><span> </span><span>u</span><span> </span><span>u&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>AbstAtomicP.simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The predicate &#8249;AbsMakeForm&#8250;&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>AbstMakeForm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hf &#8658; hf &#8658; hf &#8658; hf &#8658; hf &#8658; hf &#8658; hf &#8658; hf &#8658; hf &#8658; bool&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;AbstMakeForm k y y&#39; i u u&#39; j w w&#39; &#8801;
      Ord k &#8743;
      ((k = i &#8743; k = j &#8743; y = q_Disj u w &#8743; y&#39; = q_Disj u&#39; w&#39;) &#8744;
       (k = i &#8743; y = q_Neg u &#8743; y&#39; = q_Neg u&#39;) &#8744;
       (succ k = i &#8743; y = q_Ex u &#8743; y&#39; = q_Ex u&#39;))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>SeqAbstForm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hf &#8658; hf &#8658; hf &#8658; hf &#8658; hf &#8658; hf &#8658; bool&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SeqAbstForm v i x x&#39; s k &#8801;
       BuildSeq3 (AbstAtomic v) AbstMakeForm s k i x x&#39;&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>SeqAbstFormP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; tm &#8658; tm &#8658; tm &#8658; tm &#8658; tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom l &#9839; (s,k,v,sli,sl,sl&#39;,m,n,smi,sm,sm&#39;,sni,sn,sn&#39;);
          atom sli &#9839; (s,v,sl,sl&#39;,m,n,smi,sm,sm&#39;,sni,sn,sn&#39;);
          atom sl &#9839; (s,v,sl&#39;,m,n,smi,sm,sm&#39;,sni,sn,sn&#39;);
          atom sl&#39; &#9839; (s,v,m,n,smi,sm,sm&#39;,sni,sn,sn&#39;);
          atom m &#9839; (s,n,smi,sm,sm&#39;,sni,sn,sn&#39;);
          atom n &#9839; (s,smi,sm,sm&#39;,sni,sn,sn&#39;); atom smi &#9839; (s,sm,sm&#39;,sni,sn,sn&#39;);
          atom sm &#9839; (s,sm&#39;,sni,sn,sn&#39;); atom sm&#39; &#9839; (s,sni,sn,sn&#39;);
          atom sni &#9839; (s,sn,sn&#39;); atom sn &#9839; (s,sn&#39;); atom sn&#39; &#9839; (s)&#10215; &#10233;
    SeqAbstFormP v i x x&#39; s k =
      LstSeqP s k (HPair i (HPair x x&#39;)) AND
      All2 l (SUCC k) (Ex sli (Ex sl (Ex sl&#39; (HPair (Var l) (HPair (Var sli) (HPair (Var sl) (Var sl&#39;))) IN s AND
                (AbstAtomicP v (Var sli) (Var sl) (Var sl&#39;) OR
                OrdP (Var sli) AND
                Ex m (Ex n (Ex smi (Ex sm (Ex sm&#39; (Ex sni (Ex sn (Ex sn&#39;
                      (Var m IN Var l AND Var n IN Var l AND
                       HPair (Var m) (HPair (Var smi) (HPair (Var sm) (Var sm&#39;))) IN s AND
                       HPair (Var n) (HPair (Var sni) (HPair (Var sn) (Var sn&#39;))) IN s AND
                       ((Var sli EQ Var smi AND Var sli EQ Var sni AND
                         Var sl EQ Q_Disj (Var sm) (Var sn) AND
                         Var sl&#39; EQ Q_Disj (Var sm&#39;) (Var sn&#39;)) OR
                        (Var sli EQ Var smi AND
                         Var sl EQ Q_Neg (Var sm) AND Var sl&#39; EQ Q_Neg (Var sm&#39;)) OR
                        (SUCC (Var sli) EQ Var smi AND
                         Var sl EQ Q_Ex (Var sm) AND Var sl&#39; EQ Q_Ex (Var sm&#39;))))))))))))))))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>SeqAbstFormP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>SeqAbstFormP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; SeqAbstFormP v i x x&#39; s k &#10231; a &#9839; v &#8743; a &#9839; i &#8743; a &#9839; x &#8743; a &#9839; x&#39; &#8743; a &#9839; s &#8743; a &#9839; k&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eval_fm_SeqAbstFormP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;eval_fm e (SeqAbstFormP v i x x&#39; s k) &#10231; SeqAbstForm &#10214;v&#10215;e &#10214;i&#10215;e &#10214;x&#10215;e &#10214;x&#39;&#10215;e &#10214;s&#10215;e &#10214;k&#10215;e&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SeqAbstFormP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (SeqAbstFormP v i x x&#39; s k)&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thsf</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sli</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl&#39;</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>smi</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sm</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sm&#39;</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sni</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sn</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sn&#39;</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>atoms</span><span class="delimiter">:</span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom l &#9839; (s,k,v,sli,sl,sl&#39;,m,n,smi,sm,sm&#39;,sni,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sli &#9839; (s,v,sl,sl&#39;,m,n,smi,sm,sm&#39;,sni,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sl &#9839; (s,v,sl&#39;,m,n,smi,sm,sm&#39;,sni,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sl&#39; &#9839; (s,v,m,n,smi,sm,sm&#39;,sni,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom m &#9839; (s,n,smi,sm,sm&#39;,sni,sn,sn&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom n &#9839; (s,smi,sm,sm&#39;,sni,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom smi &#9839; (s,sm,sm&#39;,sni,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sm &#9839; (s,sm&#39;,sni,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sm&#39; &#9839; (s,sni,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sni &#9839; (s,sn,sn&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom sn &#9839; (s,sn&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom sn&#39; &#9839; s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thsf</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>LstSeqP_OrdP</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis2</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>atoms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>SeqAbstForm_def</span><span> </span><span>BuildSeq3_def</span><span> </span><span>BuildSeq_def</span><span> </span><span>Builds_def</span><span>
</span><span>              </span><span>HBall_def</span><span> </span><span>HBex_def</span><span> </span><span>q_defs</span><span> </span><span>AbstMakeForm_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>LstSeq_imp_Ord</span><span>   </span><span>Ord_trans</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;succ &#10214;k&#10215;e&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>                        </span><span>Seq_iff_app</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;s&#10215;e&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>LstSeq_imp_Seq_succ</span><span class="delimiter">]</span><span>
</span><span>              </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>conj_cong</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span class="delimiter">]</span><span> </span><span>all_cong</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SeqAbstFormP_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;(SeqAbstFormP v u x x&#39; s k)(i::=t) =
       SeqAbstFormP (subst i t v) (subst i t u) (subst i t x) (subst i t x&#39;) (subst i t s) (subst i t k)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sli</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl&#39;</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>smi</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sm</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sm&#39;</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sni</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sn</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sn&#39;</span><span class="delimiter">::</span><span>name</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom l &#9839; (i,t,s,k,v,sli,sl,sl&#39;,m,n,smi,sm,sm&#39;,sni,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sli &#9839; (i,t,s,v,sl,sl&#39;,m,n,smi,sm,sm&#39;,sni,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sl &#9839; (i,t,s,v,sl&#39;,m,n,smi,sm,sm&#39;,sni,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sl&#39; &#9839; (i,t,s,v,m,n,smi,sm,sm&#39;,sni,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom m &#9839; (i,t,s,n,smi,sm,sm&#39;,sni,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom n &#9839; (i,t,s,smi,sm,sm&#39;,sni,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom smi &#9839; (i,t,s,sm,sm&#39;,sni,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sm &#9839; (i,t,s,sm&#39;,sni,sn,sn&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom sm&#39; &#9839; (i,t,s,sni,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sni &#9839; (i,t,s,sn,sn&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom sn &#9839; (i,t,s,sn&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom sn&#39; &#9839; (i,t,s)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>SeqAbstFormP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>l</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>sli</span><span> </span><span>sl</span><span> </span><span>sl&#39;</span><span> </span><span>m</span><span> </span><span>n</span><span> </span><span>smi</span><span> </span><span>sm</span><span> </span><span>sm&#39;</span><span> </span><span>sni</span><span> </span><span>sn</span><span> </span><span>sn&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>SeqAbstFormP.simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Defining the syntax: the main AbstForm predicate&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>AbstForm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hf &#8658; hf &#8658; hf &#8658; hf &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;AbstForm v i x x&#39; &#8801; is_Var v &#8743; Ord i &#8743; (&#8707;s k. SeqAbstForm v i x x&#39; s k)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>AbstFormP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; tm &#8658; tm &#8658; tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom s &#9839; (v,i,x,x&#39;,k);
          atom k &#9839; (v,i,x,x&#39;)&#10215; &#10233;
    AbstFormP v i x x&#39; = VarP v AND OrdP i AND Ex s (Ex k (SeqAbstFormP v i x x&#39; (Var s) (Var k)))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>AbstFormP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>AbstFormP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; AbstFormP v i x x&#39; &#10231; a &#9839; v &#8743; a &#9839; i &#8743; a &#9839; x &#8743; a &#9839; x&#39;&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eval_fm_AbstFormP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;eval_fm e (AbstFormP v i x x&#39;) &#10231; AbstForm &#10214;v&#10215;e &#10214;i&#10215;e &#10214;x&#10215;e &#10214;x&#39;&#10215;e&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>AbstFormP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (AbstFormP v i x x&#39;)&quot;</span></span></span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thsf</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>k</span><span class="delimiter">::</span><span>name</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom s &#9839; (v,i,x,x&#39;,k)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom k &#9839; (v,i,x,x&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thesis2</span><span> </span><span class="var">?thsf</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>AbstForm_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>AbstFormP_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;(AbstFormP v i x x&#39;)(j::=t) = AbstFormP (subst j t v) (subst j t i) (subst j t x) (subst j t x&#39;)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>k</span><span class="delimiter">::</span><span>name</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom s &#9839; (v,i,x,x&#39;,t,j,k)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom k &#9839; (v,i,x,x&#39;,t,j)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>AbstFormP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>k</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>AbstFormP.simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Correctness: It Coincides with Abstraction over real Formulas&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>AbstForm_imp_Ord</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;AbstForm v u x x&#39; &#10233; Ord v&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>AbstForm_def</span><span> </span><span>is_Var_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>AbstForm_imp_abst_dbfm</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;AbstForm v i x x&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;A. x = &#10214;quot_dbfm A&#10215;e &#8743;
             x&#39; = &#10214;quot_dbfm (abst_dbfm (decode_Var v) (nat_of_ord i) A)&#10215;e&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span> </span><span>k</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>v</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Var v&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Ord i&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sk</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SeqAbstForm v i x x&#39; s k&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>AbstForm_def</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>sk</span><span> </span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>SeqAbstForm_def</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>i</span><span> </span><span>x</span><span> </span><span>x&#39;</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>BuildSeq3_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>B</span><span> </span><span>i</span><span> </span><span>x</span><span> </span><span>x&#39;</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>AbstAtomic_def</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>AbstTerm_imp_abst_dbtm</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>e</span><span class="delimiter">=</span><span>e</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;DBEq ta tb&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;DBMem ta tb&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>q_defs</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>C</span><span> </span><span>i</span><span> </span><span>x</span><span> </span><span>x&#39;</span><span> </span><span>j</span><span> </span><span>y</span><span> </span><span>y&#39;</span><span> </span><span>k</span><span> </span><span>z</span><span> </span><span>z&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>A1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>A2</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y = &#10214;quot_dbfm A1&#10215;e&quot;</span></span></span><span>
</span><span>            </span><span class="string"><span class="delete"><span class="delete">&quot;y&#39; = &#10214;quot_dbfm (abst_dbfm (decode_Var v) (nat_of_ord j) A1)&#10215;e&quot;</span></span></span><span>
</span><span>            </span><span class="string"><span class="delete"><span class="delete">&quot;z = &#10214;quot_dbfm A2&#10215;e&quot;</span></span></span><span>
</span><span>            </span><span class="string"><span class="delete"><span class="delete">&quot;z&#39; = &#10214;quot_dbfm (abst_dbfm (decode_Var v) (nat_of_ord k) A2)&#10215;e&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>C.hyps</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>AbstMakeForm_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;DBDisj A1 A2&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;DBNeg A1&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span class="delimiter">[</span><span>3</span><span class="delimiter">]</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;DBEx A1&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>C</span><span> </span><span>q_defs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>AbstForm_abst_dbfm</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;AbstForm (q_Var i) (ord_of n) &#10214;quot_dbfm fm&#10215;e &#10214;quot_dbfm (abst_dbfm i n fm)&#10215;e&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>fm</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>n</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>dbfm.induct</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>AbstForm_def</span><span> </span><span>SeqAbstForm_def</span><span> </span><span>AbstMakeForm_def</span><span> </span><span>AbstAtomic_def</span><span>
</span><span>                       </span><span>AbstTerm_abst_dbtm</span><span> </span><span>htuple_minus_1</span><span> </span><span>q_defs</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>q_Var_def</span><span>
</span><span>             </span><span>intro</span><span class="delimiter">:</span><span> </span><span>BuildSeq3_exI</span><span> </span><span>BuildSeq3_combine</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Substitution over formulas&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The predicate &#8249;SubstAtomicP&#8250;&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>SubstAtomic</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hf &#8658; hf &#8658; hf &#8658; hf &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SubstAtomic v tm y y&#39; &#8801; 
            (&#8707;t u t&#39; u&#39;. SubstTerm v tm t t&#39; &#8743; SubstTerm v tm u u&#39; &#8743;
             ((y = q_Eq t u &#8743; y&#39; = q_Eq t&#39; u&#39;) &#8744; (y = q_Mem t u &#8743; y&#39; = q_Mem t&#39; u&#39;)))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>SubstAtomicP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; tm &#8658; tm &#8658; tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom t &#9839; (v,tm,y,y&#39;,t&#39;,u,u&#39;);
          atom t&#39; &#9839; (v,tm,y,y&#39;,u,u&#39;);
          atom u &#9839; (v,tm,y,y&#39;,u&#39;);
          atom u&#39; &#9839; (v,tm,y,y&#39;)&#10215; &#10233;
    SubstAtomicP v tm y y&#39; =
         Ex t (Ex u (Ex t&#39; (Ex u&#39;
           (SubstTermP v tm (Var t) (Var t&#39;) AND SubstTermP v tm (Var u) (Var u&#39;) AND
                      ((y EQ Q_Eq (Var t) (Var u) AND y&#39; EQ Q_Eq (Var t&#39;) (Var u&#39;)) OR
                       (y EQ Q_Mem (Var t) (Var u) AND y&#39; EQ Q_Mem (Var t&#39;) (Var u&#39;)))))))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>SubstAtomicP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>SubstAtomicP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; SubstAtomicP v tm y y&#39; &#10231; a &#9839; v &#8743; a &#9839; tm &#8743; a &#9839; y &#8743; a &#9839; y&#39;&quot;</span></span></span><span>           </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eval_fm_SubstAtomicP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;eval_fm e (SubstAtomicP v tm y y&#39;) &#10231; SubstAtomic &#10214;v&#10215;e &#10214;tm&#10215;e &#10214;y&#10215;e &#10214;y&#39;&#10215;e&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SubstAtomicP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (SubstAtomicP v tm y y&#39;)&quot;</span></span></span><span>               </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thsf</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>u</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t&#39;</span><span class="delimiter">::</span><span>name</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>u&#39;</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom t &#9839; (v,tm,y,y&#39;,t&#39;,u,u&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom t&#39; &#9839; (v,tm,y,y&#39;,u,u&#39;)&quot;</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;atom u &#9839; (v,tm,y,y&#39;,u&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom u&#39; &#9839; (v,tm,y,y&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thesis2</span><span> </span><span class="var">?thsf</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>SubstAtomic_def</span><span> </span><span>q_defs</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SubstAtomicP_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(SubstAtomicP v tm y y&#39;)(i::=w) = SubstAtomicP (subst i w v) (subst i w tm) (subst i w y) (subst i w y&#39;)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>u</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t&#39;</span><span class="delimiter">::</span><span>name</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>u&#39;</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom t &#9839; (v,tm,y,y&#39;,w,i,t&#39;,u,u&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom t&#39; &#9839; (v,tm,y,y&#39;,w,i,u,u&#39;)&quot;</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;atom u &#9839; (v,tm,y,y&#39;,w,i,u&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom u&#39; &#9839; (v,tm,y,y&#39;,w,i)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>SubstAtomicP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>t</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>t&#39;</span><span> </span><span>u</span><span> </span><span>u&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SubstAtomicP_cong</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;H &#8866; v EQ v&#39;; H &#8866; tm EQ tm&#39;; H &#8866; x EQ x&#39;; H &#8866; y EQ y&#39;&#10215;
   &#10233; H &#8866; SubstAtomicP v tm x y IFF SubstAtomicP v&#39; tm&#39; x&#39; y&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>P4_cong</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The predicate &#8249;SubstMakeForm&#8250;&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>SubstMakeForm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hf &#8658; hf &#8658; hf &#8658; hf &#8658; hf &#8658; hf &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SubstMakeForm y y&#39; u u&#39; w w&#39; &#8801;
          ((y = q_Disj u w &#8743; y&#39; = q_Disj u&#39; w&#39;) &#8744;
           (y = q_Neg u &#8743; y&#39; = q_Neg u&#39;) &#8744;
           (y = q_Ex u &#8743; y&#39; = q_Ex u&#39;))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>SeqSubstForm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hf &#8658; hf &#8658; hf &#8658; hf &#8658; hf &#8658; hf &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SeqSubstForm v u x x&#39; s k &#8801; BuildSeq2 (SubstAtomic v u) SubstMakeForm s k x x&#39;&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>SeqSubstFormP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; tm &#8658; tm &#8658; tm &#8658; tm &#8658; tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom l &#9839; (s,k,v,u,sl,sl&#39;,m,n,sm,sm&#39;,sn,sn&#39;);
          atom sl &#9839; (s,v,u,sl&#39;,m,n,sm,sm&#39;,sn,sn&#39;);
          atom sl&#39; &#9839; (s,v,u,m,n,sm,sm&#39;,sn,sn&#39;);
          atom m &#9839; (s,n,sm,sm&#39;,sn,sn&#39;); atom n &#9839; (s,sm,sm&#39;,sn,sn&#39;);
          atom sm &#9839; (s,sm&#39;,sn,sn&#39;); atom sm&#39; &#9839; (s,sn,sn&#39;);
          atom sn &#9839; (s,sn&#39;); atom sn&#39; &#9839; s&#10215; &#10233;
    SeqSubstFormP v u x x&#39; s k =
      LstSeqP s k (HPair x x&#39;) AND
      All2 l (SUCC k) (Ex sl (Ex sl&#39; (HPair (Var l) (HPair (Var sl) (Var sl&#39;)) IN s AND
                (SubstAtomicP v u (Var sl) (Var sl&#39;) OR
                Ex m (Ex n (Ex sm (Ex sm&#39; (Ex sn (Ex sn&#39; (Var m IN Var l AND Var n IN Var l AND
                       HPair (Var m) (HPair (Var sm) (Var sm&#39;)) IN s AND
                       HPair (Var n) (HPair (Var sn) (Var sn&#39;)) IN s AND
                       ((Var sl EQ Q_Disj (Var sm) (Var sn) AND
                        Var sl&#39; EQ Q_Disj (Var sm&#39;) (Var sn&#39;)) OR
                        (Var sl EQ Q_Neg (Var sm) AND Var sl&#39; EQ Q_Neg (Var sm&#39;)) OR
                        (Var sl EQ Q_Ex (Var sm) AND Var sl&#39; EQ Q_Ex (Var sm&#39;)))))))))))))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>SeqSubstFormP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>SeqSubstFormP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; SeqSubstFormP v u x x&#39; s k &#10231; a &#9839; v &#8743; a &#9839; u &#8743; a &#9839; x &#8743; a &#9839; x&#39; &#8743; a &#9839; s &#8743; a &#9839; k&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eval_fm_SeqSubstFormP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;eval_fm e (SeqSubstFormP v u x x&#39; s k) &#10231; 
         SeqSubstForm &#10214;v&#10215;e &#10214;u&#10215;e &#10214;x&#10215;e &#10214;x&#39;&#10215;e &#10214;s&#10215;e &#10214;k&#10215;e&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SeqSubstFormP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (SeqSubstFormP v u x x&#39; s k)&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thsf</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SeqSubstFormP_imp_OrdP</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;{ SeqSubstFormP v u x x&#39; s k } &#8866; OrdP k&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thOrd</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SeqSubstFormP_imp_LstSeqP</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;{ SeqSubstFormP v u x x&#39; s k } &#8866; LstSeqP s k (HPair x x&#39;)&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thLstSeq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl&#39;</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>sm</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sm&#39;</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sn</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sn&#39;</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>atoms</span><span class="delimiter">:</span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom l &#9839; (s,k,v,u,sl,sl&#39;,m,n,sm,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sl &#9839; (s,v,u,sl&#39;,m,n,sm,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sl&#39; &#9839; (s,v,u,m,n,sm,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom m &#9839; (s,n,sm,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom n &#9839; (s,sm,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sm &#9839; (s,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom sm&#39; &#9839; (s,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sn &#9839; (s,sn&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom sn&#39; &#9839; (s)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thsf</span><span> </span><span class="var">?thOrd</span><span> </span><span class="var">?thLstSeq</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>LstSeqP_OrdP</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis2</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>atoms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>SeqSubstForm_def</span><span> </span><span>BuildSeq2_def</span><span> </span><span>BuildSeq_def</span><span> </span><span>Builds_def</span><span>
</span><span>                 </span><span>HBall_def</span><span> </span><span>HBex_def</span><span> </span><span>q_defs</span><span> </span><span>SubstMakeForm_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>LstSeq_imp_Ord</span><span>   </span><span>Ord_trans</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;succ &#10214;k&#10215;e&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>                 </span><span>Seq_iff_app</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;s&#10215;e&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>LstSeq_imp_Seq_succ</span><span class="delimiter">]</span><span>
</span><span>              </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>conj_cong</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span class="delimiter">]</span><span>  </span><span>all_cong</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SeqSubstFormP_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;(SeqSubstFormP v u x x&#39; s k)(i::=t) =
       SeqSubstFormP (subst i t v) (subst i t u) (subst i t x) (subst i t x&#39;) (subst i t s) (subst i t k)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl&#39;</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>sm</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sm&#39;</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sn</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sn&#39;</span><span class="delimiter">::</span><span>name</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom l &#9839; (s,k,v,u,t,i,sl,sl&#39;,m,n,sm,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sl &#9839; (s,v,u,t,i,sl&#39;,m,n,sm,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sl&#39; &#9839; (s,v,u,t,i,m,n,sm,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom m &#9839; (s,t,i,n,sm,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom n &#9839; (s,t,i,sm,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sm &#9839; (s,t,i,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom sm&#39; &#9839; (s,t,i,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sn &#9839; (s,t,i,sn&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom sn&#39; &#9839; (s,t,i)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>SeqSubstFormP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>l</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>sl</span><span> </span><span>sl&#39;</span><span> </span><span>m</span><span> </span><span>n</span><span> </span><span>sm</span><span> </span><span>sm&#39;</span><span> </span><span>sn</span><span> </span><span>sn&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SeqSubstFormP_cong</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;H &#8866; t EQ t&#39;; H &#8866; u EQ u&#39;; H &#8866; s EQ s&#39;; H &#8866; k EQ k&#39;&#10215;
   &#10233; H &#8866; SeqSubstFormP v i t u s k IFF SeqSubstFormP v i t&#39; u&#39; s&#39; k&#39;&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>P4_cong</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>tms</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;[v,i]&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fresh_Cons</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>SeqSubstFormP.simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Defining the syntax: the main SubstForm predicate&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>SubstForm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hf &#8658; hf &#8658; hf &#8658; hf &#8658; bool&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SubstForm v u x x&#39; &#8801; is_Var v &#8743; Term u &#8743; (&#8707;s k. SeqSubstForm v u x x&#39; s k)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>SubstFormP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; tm &#8658; tm &#8658; tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom s &#9839; (v,i,x,x&#39;,k); atom k &#9839; (v,i,x,x&#39;)&#10215; &#10233;
    SubstFormP v i x x&#39; =
      VarP v AND TermP i AND Ex s (Ex k (SeqSubstFormP v i x x&#39; (Var s) (Var k)))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>SubstFormP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>SubstFormP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; SubstFormP v i x x&#39; &#10231; a &#9839; v &#8743; a &#9839; i &#8743; a &#9839; x &#8743; a &#9839; x&#39;&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eval_fm_SubstFormP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;eval_fm e (SubstFormP v i x x&#39;) &#10231; SubstForm &#10214;v&#10215;e &#10214;i&#10215;e &#10214;x&#10215;e &#10214;x&#39;&#10215;e&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SubstFormP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (SubstFormP v i x x&#39;)&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thsf</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>k</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom s &#9839; (v,i,x,x&#39;,k)&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;atom k &#9839; (v,i,x,x&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thesis2</span><span> </span><span class="var">?thsf</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>SubstForm_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SubstFormP_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;(SubstFormP v i x x&#39;)(j::=t) = SubstFormP (subst j t v) (subst j t i) (subst j t x) (subst j t x&#39;)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>k</span><span class="delimiter">::</span><span>name</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom s &#9839; (v,i,x,x&#39;,t,j,k)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom k &#9839; (v,i,x,x&#39;,t,j)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>SubstFormP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>k</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SubstFormP_cong</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;H &#8866; v EQ v&#39;; H &#8866; i EQ i&#39;; H &#8866; t EQ t&#39;; H &#8866; u EQ u&#39;&#10215;
   &#10233; H &#8866; SubstFormP v i t u IFF SubstFormP v&#39; i&#39; t&#39; u&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>P4_cong</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ground_SubstFormP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ground_fm (SubstFormP v y x x&#39;) &#10231; ground v &#8743; ground y &#8743; ground x &#8743; ground x&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ground_aux_def</span><span> </span><span>ground_fm_aux_def</span><span> </span><span>supp_conv_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>SubstFormP.simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Correctness of substitution over formulas&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SubstForm_imp_subst_dbfm_lemma</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SubstForm v &#10214;quot_dbtm u&#10215;e x x&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;A. x = &#10214;quot_dbfm A&#10215;e &#8743;
               x&#39; = &#10214;quot_dbfm (subst_dbfm u (decode_Var v) A)&#10215;e&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span> </span><span>k</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>v</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Var v&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Term &#10214;quot_dbtm u&#10215;e&quot;</span></span></span><span>
</span><span>               </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sk</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SeqSubstForm v &#10214;quot_dbtm u&#10215;e x x&#39; s k&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>SubstForm_def</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>sk</span><span> </span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>SeqSubstForm_def</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>x</span><span> </span><span>x&#39;</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>BuildSeq2_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>B</span><span> </span><span>x</span><span> </span><span>x&#39;</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>SubstAtomic_def</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>SubstTerm_imp_subst_dbtm&#39;</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>e</span><span class="delimiter">=</span><span>e</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;DBEq ta tb&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;DBMem ta tb&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>q_defs</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>C</span><span> </span><span>x</span><span> </span><span>x&#39;</span><span> </span><span>y</span><span> </span><span>y&#39;</span><span> </span><span>z</span><span> </span><span>z&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>A</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>B</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y = &#10214;quot_dbfm A&#10215;e&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y&#39; = &#10214;quot_dbfm (subst_dbfm u (decode_Var v) A)&#10215;e&quot;</span></span></span><span>
</span><span>            </span><span class="string"><span class="delete"><span class="delete">&quot;z = &#10214;quot_dbfm B&#10215;e&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;z&#39; = &#10214;quot_dbfm (subst_dbfm u (decode_Var v) B)&#10215;e&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>C.hyps</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>SubstMakeForm_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;DBDisj A B&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;DBNeg A&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span class="delimiter">[</span><span>3</span><span class="delimiter">]</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;DBEx A&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>C</span><span> </span><span>q_defs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SubstForm_imp_subst_dbfm</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SubstForm v u x x&#39;&quot;</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>t</span><span> </span><span>A</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u = &#10214;quot_dbtm t&#10215;e&quot;</span></span></span><span>
</span><span>                     </span><span class="string"><span class="delete"><span class="delete">&quot;x = &#10214;quot_dbfm A&#10215;e&quot;</span></span></span><span>
</span><span>                     </span><span class="string"><span class="delete"><span class="delete">&quot;x&#39; = &#10214;quot_dbfm (subst_dbfm t (decode_Var v) A)&#10215;e&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u = &#10214;quot_dbtm t&#10215;e&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>SubstForm_def</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Term_imp_wf_dbtm</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>SubstForm_imp_subst_dbfm_lemma</span><span> </span><span>assms</span><span> </span><span>that</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SubstForm_subst_dbfm</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_dbtm u&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SubstForm (q_Var i) &#10214;quot_dbtm u&#10215;e &#10214;quot_dbfm A&#10215;e
                             &#10214;quot_dbfm (subst_dbfm u i A)&#10215;e&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>A</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>dbfm.induct</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>u</span><span> </span><span>SubstForm_def</span><span> </span><span>SeqSubstForm_def</span><span> </span><span>SubstAtomic_def</span><span> </span><span>SubstMakeForm_def</span><span> 
</span><span>                   </span><span>SubstTerm_subst_dbtm</span><span> </span><span>q_defs</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>q_Var_def</span><span>
</span><span>           </span><span>intro</span><span class="delimiter">:</span><span> </span><span>BuildSeq2_exI</span><span> </span><span>BuildSeq2_combine</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>SubstForm_subst_dbfm_eq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;v = q_Var i; Term ux; ux = &#10214;quot_dbtm u&#10215;e; A&#39; = subst_dbfm u i A&#10215;
   &#10233; SubstForm v ux &#10214;quot_dbfm A&#10215;e &#10214;quot_dbfm A&#39;&#10215;e&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>SubstForm_subst_dbfm</span><span> </span><span>Term_imp_is_tm</span><span> </span><span>quot_dbtm_inject_lemma</span><span> </span><span>quot_tm_def</span><span> </span><span>wf_dbtm_iff_is_tm</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The predicate &#8249;AtomicP&#8250;&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Atomic</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hf &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Atomic y &#8801;&#8707;t u. Term t &#8743; Term u &#8743; (y = q_Eq t u &#8744; y = q_Mem t u)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>AtomicP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom t &#9839; (u,y); atom u &#9839; y&#10215; &#10233;
    AtomicP y = Ex t (Ex u (TermP (Var t) AND TermP (Var u) AND
                      (y EQ Q_Eq (Var t) (Var u) OR
                       y EQ Q_Mem (Var t) (Var u))))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>AtomicP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>AtomicP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; AtomicP y &#10231; a &#9839; y&quot;</span></span></span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eval_fm_AtomicP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;eval_fm e (AtomicP y) &#10231; Atomic&#10214;y&#10215;e&quot;</span></span></span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>AtomicP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (AtomicP y)&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thsf</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>u</span><span class="delimiter">::</span><span>name</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom t &#9839; (u,y)&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;atom u &#9839; y&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thesis2</span><span> </span><span class="var">?thsf</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Atomic_def</span><span> </span><span>q_defs</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The predicate &#8249;MakeForm&#8250;&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>MakeForm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hf &#8658; hf &#8658; hf &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;MakeForm y u w &#8801;
         y = q_Disj u w &#8744; y = q_Neg u &#8744;
         (&#8707;v u&#39;. AbstForm v 0 u u&#39; &#8743; y = q_Ex u&#39;)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>MakeFormP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; tm &#8658; tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom v &#9839; (y,u,w,au); atom au &#9839; (y,u,w)&#10215; &#10233;
    MakeFormP y u w =
      y EQ Q_Disj u w OR y EQ Q_Neg u OR
      Ex v (Ex au (AbstFormP (Var v) Zero u (Var au) AND y EQ Q_Ex (Var au)))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>MakeFormP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>MakeFormP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; MakeFormP y u w &#10231; a &#9839; y &#8743; a &#9839; u &#8743; a &#9839; w&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eval_fm_MakeFormP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;eval_fm e (MakeFormP y u w) &#10231; MakeForm &#10214;y&#10215;e &#10214;u&#10215;e &#10214;w&#10215;e&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>MakeFormP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (MakeFormP y u w)&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thsf</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>v</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>au</span><span class="delimiter">::</span><span>name</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom v &#9839; (y,u,w,au)&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;atom au &#9839; (y,u,w)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thesis2</span><span> </span><span class="var">?thsf</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>MakeForm_def</span><span> </span><span>q_defs</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>MakeFormP.simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The predicate &#8249;SeqFormP&#8250;&#8250;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*SeqForm(s,k,t) &#8801; LstSeq(s,k,t) &#8743; (&#8704;n&#8712;k)[Atomic (s n) &#8744; (&#8707;m,l&#8712;n)[MakeForm (s m) (s l) (s n)]]*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>SeqForm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hf &#8658; hf &#8658; hf &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SeqForm s k y &#8801; BuildSeq Atomic MakeForm s k y&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>SeqFormP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; tm &#8658; tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom l &#9839; (s,k,t,sl,m,n,sm,sn); atom sl &#9839; (s,k,t,m,n,sm,sn);
          atom m &#9839; (s,k,t,n,sm,sn); atom n &#9839; (s,k,t,sm,sn);
          atom sm &#9839; (s,k,t,sn); atom sn &#9839; (s,k,t)&#10215; &#10233;
    SeqFormP s k t =
      LstSeqP s k t AND
      All2 n (SUCC k) (Ex sn (HPair (Var n) (Var sn) IN s AND (AtomicP (Var sn) OR
                Ex m (Ex l (Ex sm (Ex sl (Var m IN Var n AND Var l IN Var n AND
                       HPair (Var m) (Var sm) IN s AND HPair (Var l) (Var sl) IN s AND
                       MakeFormP (Var sn) (Var sm) (Var sl))))))))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>SeqFormP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>SeqFormP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; SeqFormP s k t &#10231; a &#9839; s &#8743; a &#9839; k &#8743; a &#9839; t&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eval_fm_SeqFormP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;eval_fm e (SeqFormP s k t) &#10231; SeqForm &#10214;s&#10215;e &#10214;k&#10215;e &#10214;t&#10215;e&quot;</span></span></span><span>   </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SeqFormP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (SeqFormP s k t)&quot;</span></span></span><span>          </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thsf</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sm</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sn</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>atoms</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom l &#9839; (s,k,t,sl,m,n,sm,sn)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom sl &#9839; (s,k,t,m,n,sm,sn)&quot;</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;atom m &#9839; (s,k,t,n,sm,sn)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom n &#9839; (s,k,t,sm,sn)&quot;</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;atom sm &#9839; (s,k,t,sn)&quot;</span></span></span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;atom sn &#9839; (s,k,t)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thsf</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis2</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>atoms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>conj_cong</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>LstSeq_imp_Ord</span><span> </span><span>SeqForm_def</span><span> </span><span>BuildSeq_def</span><span> </span><span>Builds_def</span><span>
</span><span>             </span><span>HBall_def</span><span> </span><span>HBex_def</span><span> </span><span>q_defs</span><span> 
</span><span>             </span><span>Seq_iff_app</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;s&#10215;e&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>LstSeq_imp_Seq_succ</span><span class="delimiter">]</span><span>
</span><span>             </span><span>Ord_trans</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;succ &#10214;k&#10215;e&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SeqFormP_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;(SeqFormP s k t)(j::=w) = SeqFormP (subst j w s) (subst j w k) (subst j w t)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sm</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sn</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom l &#9839; (j,w,s,t,k,sl,m,n,sm,sn)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom sl &#9839; (j,w,s,k,t,m,n,sm,sn)&quot;</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;atom m &#9839; (j,w,s,k,t,n,sm,sn)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom n &#9839; (j,w,s,k,t,sm,sn)&quot;</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;atom sm &#9839; (j,w,s,k,t,sn)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom sn &#9839; (j,w,s,k,t)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>SeqFormP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>l</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>sl</span><span> </span><span>m</span><span> </span><span>n</span><span> </span><span>sm</span><span> </span><span>sn</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The predicate &#8249;FormP&#8250;&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Definition&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Form</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hf &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Form y &#8801; (&#8707;s k. SeqForm s k y)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>FormP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom k &#9839; (s,y); atom s &#9839; y&#10215; &#10233;
    FormP y = Ex k (Ex s (SeqFormP (Var s) (Var k) y))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>FormP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>FormP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; FormP y &#10231; a &#9839; y&quot;</span></span></span><span>              </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eval_fm_FormP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;eval_fm e (FormP y) &#10231; Form &#10214;y&#10215;e&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>FormP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (FormP y)&quot;</span></span></span><span>                 </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thsf</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>k</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span class="delimiter">::</span><span>name</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>k</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom k &#9839; (s,y)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom s &#9839; y&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thesis2</span><span> </span><span class="var">?thsf</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Form_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FormP_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(FormP y)(j::=w) = FormP (subst j w y)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>k</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom k &#9839; (s,j,w,y)&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;atom s &#9839; (j,w,y)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>FormP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>k</span><span> </span><span>s</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Correctness: It Corresponds to Quotations of Real Formulas&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>AbstForm_trans_fm</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;AbstForm (q_Var i) 0 &#10214;&#171;A&#187;&#10215;e &#10214;quot_dbfm (trans_fm [i] A)&#10215;e&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>abst_trans_fm</span><span> </span><span>ord_of.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>quot_fm_def</span><span> </span><span>AbstForm_abst_dbfm</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>AbstForm_trans_fm_eq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;x = &#10214;&#171;A&#187;&#10215; e;  x&#39; = &#10214;quot_dbfm (trans_fm [i] A)&#10215;e&#10215; &#10233; AbstForm (q_Var i) 0 x x&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>AbstForm_trans_fm</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_Form_quot_dbfm</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_dbfm A&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Form &#10214;quot_dbfm A&#10215;e&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>wf_dbfm.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Mem</span><span> </span><span>tm1</span><span> </span><span>tm2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Atomic &#10214;quot_dbfm (DBMem tm1 tm2)&#10215;e&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Atomic_def</span><span> </span><span>quot_Mem</span><span> </span><span>q_Mem_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>wf_Term_quot_dbtm</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Form_def</span><span> </span><span>SeqForm_def</span><span> </span><span>BuildSeq_exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Eq</span><span> </span><span>tm1</span><span> </span><span>tm2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Atomic &#10214;quot_dbfm (DBEq tm1 tm2)&#10215;e&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Atomic_def</span><span> </span><span>quot_Eq</span><span> </span><span>q_Eq_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>wf_Term_quot_dbtm</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Form_def</span><span> </span><span>SeqForm_def</span><span> </span><span>BuildSeq_exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Disj</span><span> </span><span>A1</span><span> </span><span>A2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;MakeForm &#10214;quot_dbfm (DBDisj A1 A2)&#10215;e &#10214;quot_dbfm A1&#10215;e &#10214;quot_dbfm A2&#10215;e&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>quot_Disj</span><span> </span><span>q_Disj_def</span><span> </span><span>MakeForm_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Disj</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Form_def</span><span> </span><span>SeqForm_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>BuildSeq_combine</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Neg</span><span> </span><span>A</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;y. MakeForm &#10214;quot_dbfm (DBNeg A)&#10215;e &#10214;quot_dbfm A&#10215;e y&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>quot_Neg</span><span> </span><span>q_Neg_def</span><span> </span><span>MakeForm_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Neg</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Form_def</span><span> </span><span>SeqForm_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>BuildSeq_combine</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Ex</span><span> </span><span>A</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;A y. MakeForm &#10214;quot_dbfm (DBEx (abst_dbfm i 0 A))&#10215;e &#10214;quot_dbfm A&#10215;e y&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>quot_Ex</span><span> </span><span>q_defs</span><span> </span><span>MakeForm_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>AbstForm_abst_dbfm</span><span> </span><span>ord_of.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ex</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Form_def</span><span> </span><span>SeqForm_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>BuildSeq_combine</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Form_quot_fm</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>A</span><span> </span><span class="delimiter">::</span><span> </span><span>fm</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Form &#10214;&#171;A&#187;&#10215;e&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>quot_fm_def</span><span> </span><span>wf_Form_quot_dbfm</span><span> </span><span>wf_dbfm_trans_fm</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Atomic_Form_is_wf_dbfm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Atomic x &#10233; &#8707;A. wf_dbfm A &#8743; x = &#10214;quot_dbfm A&#10215;e&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Atomic_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span> </span><span>u</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Term t&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Term u&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>tm1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tm2</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>tm1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_dbtm tm1&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t = &#10214;quot_dbtm tm1&#10215;e&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tm2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_dbtm tm2&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u = &#10214;quot_dbtm tm2&#10215;e&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Term_imp_is_tm</span><span> </span><span>quot_tm_def</span><span> </span><span>wf_dbtm_trans_tm</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;A. wf_dbfm A &#8743; q_Eq t u = &#10214;quot_dbfm A&#10215;e&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>quot_Eq</span><span> </span><span>q_Eq_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span> </span><span>u</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Term t&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Term u&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>tm1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tm2</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>tm1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_dbtm tm1&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t = &#10214;quot_dbtm tm1&#10215;e&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tm2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_dbtm tm2&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u = &#10214;quot_dbtm tm2&#10215;e&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Term_imp_is_tm</span><span> </span><span>quot_tm_def</span><span> </span><span>wf_dbtm_trans_tm</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;A. wf_dbfm A &#8743; q_Mem t u = &#10214;quot_dbfm A&#10215;e&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>quot_Mem</span><span> </span><span>q_Mem_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SeqForm_imp_wf_dbfm</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SeqForm s k x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;A. wf_dbfm A &#8743; x = &#10214;quot_dbfm A&#10215;e&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>SeqForm_def</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>x</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>BuildSeq_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>B</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Atomic_Form_is_wf_dbfm</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>C</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>A</span><span> </span><span>B</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_dbfm A&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y = &#10214;quot_dbfm A&#10215;e&quot;</span></span></span><span>
</span><span>                        </span><span class="string"><span class="delete"><span class="delete">&quot;wf_dbfm B&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;z = &#10214;quot_dbfm B&#10215;e&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>MakeForm_def</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>AbstForm_imp_abst_dbfm</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>e</span><span class="delimiter">=</span><span>e</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;DBDisj A B&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;DBNeg A&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span class="delimiter">[</span><span>3</span><span class="delimiter">]</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;DBEx (abst_dbfm (decode_Var v) 0 A)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>q_defs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Form_imp_wf_dbfm</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Form x&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>A</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_dbfm A&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x = &#10214;quot_dbfm A&#10215;e&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>SeqForm_imp_wf_dbfm</span><span> </span><span>Form_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Form_imp_is_fm</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Form x&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>A</span><span class="delimiter">::</span><span>fm</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x = &#10214;&#171;A&#187;&#10215; e&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>Form_imp_wf_dbfm</span><span> </span><span>quot_fm_def</span><span> </span><span>wf_dbfm_imp_is_fm</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SubstForm_imp_subst_fm</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SubstForm v &#10214;&#171;u&#187;&#10215;e x x&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Form x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>A</span><span class="delimiter">::</span><span>fm</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x = &#10214;&#171;A&#187;&#10215; e&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#39; = &#10214;&#171;A(decode_Var v::=u)&#187;&#10215; e&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>quot_tm_def</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>quot_fm_def</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>SubstForm_imp_subst_dbfm_lemma</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Form_imp_is_fm</span><span> </span><span>eval_quot_dbfm_ignore</span><span> </span><span>quot_dbfm_inject_lemma</span><span> </span><span>quot_fm_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SubstForm_unique</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Var v&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Term y&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Form x&quot;</span></span></span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SubstForm v y x x&#39; &#10231;
            (&#8707;t::tm. y = &#10214;&#171;t&#187;&#10215;e &#8743; (&#8707;A::fm. x = &#10214;&#171;A&#187;&#10215;e &#8743; x&#39; = &#10214;&#171;A(decode_Var v::=t)&#187;&#10215;e))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>Term_imp_wf_dbtm</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>e</span><span class="delimiter">=</span><span>e</span><span class="delimiter">]</span><span> </span><span>Form_imp_is_fm</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>e</span><span class="delimiter">=</span><span>e</span><span class="delimiter">]</span><span> 
</span><span>                     </span><span>SubstForm_imp_subst_dbfm</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>e</span><span class="delimiter">=</span><span>e</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>quot_tm_def</span><span> </span><span>quot_fm_def</span><span> </span><span>is_Var_iff</span><span> </span><span>q_Var_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>SubstForm_subst_dbfm_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>subst_fm_trans_commute</span><span> </span><span>wf_dbtm_imp_is_tm</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SubstForm_quot_unique</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SubstForm (q_Var i) &#10214;&#171;t&#187;&#10215;e &#10214;&#171;A&#187;&#10215;e x&#39; &#10231; x&#39; = &#10214;&#171;A(i::=t)&#187;&#10215; e&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>SubstForm_unique</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>e</span><span class="delimiter">=</span><span>e</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SubstForm_quot</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SubstForm &#10214;&#171;Var i&#187;&#10215;e &#10214;&#171;t&#187;&#10215;e &#10214;&#171;A&#187;&#10215;e &#10214;&#171;A(i::=t)&#187;&#10215;e&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>SubstForm_quot_unique</span><span> </span><span>eval_Var_q</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The predicate &#8249;VarNonOccFormP&#8250; (Derived from &#8249;SubstFormP&#8250;)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>VarNonOccForm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hf &#8658; hf &#8658; bool&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;VarNonOccForm v x &#8801; Form x &#8743; SubstForm v 0 x x&quot;</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>VarNonOccFormP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;VarNonOccFormP v x = FormP x AND SubstFormP v Zero x x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>VarNonOccFormP_graph_aux_def</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>VarNonOccFormP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; VarNonOccFormP v y &#10231; a &#9839; v &#8743; a &#9839; y&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eval_fm_VarNonOccFormP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;eval_fm e (VarNonOccFormP v y) &#10231; VarNonOccForm &#10214;v&#10215;e &#10214;y&#10215;e&quot;</span></span></span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VarNonOccFormP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (VarNonOccFormP v y)&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thsf</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thsf</span><span> </span><span class="var">?thesis2</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>VarNonOccForm_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Correctness for Real Terms and Formulas&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>VarNonOccForm_imp_dbfm_fresh</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;VarNonOccForm v x&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;A. wf_dbfm A &#8743; x = &#10214;quot_dbfm A&#10215;e &#8743; atom (decode_Var v) &#9839; A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>A&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_dbfm A&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x = &#10214;quot_dbfm A&#39;&#10215;e&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SubstForm v &#10214;quot_dbtm DBZero&#10215;e x x&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>VarNonOccForm_def</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Form_imp_wf_dbfm</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>A</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x = &#10214;quot_dbfm A&#10215;e&quot;</span></span></span><span>
</span><span>                      </span><span class="string"><span class="delete"><span class="delete">&quot;x = &#10214;quot_dbfm (subst_dbfm DBZero (decode_Var v) A)&#10215;e&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>SubstForm_imp_subst_dbfm_lemma</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A&#39;</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fresh_iff_non_subst_dbfm</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>VarNonOccForm_imp_fresh</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;VarNonOccForm v x&quot;</span></span></span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>A</span><span class="delimiter">::</span><span>fm</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x = &#10214;&#171;A&#187;&#10215;e&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom (decode_Var v) &#9839; A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>VarNonOccForm_imp_dbfm_fresh</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">,</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>e</span><span class="delimiter">=</span><span>e</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>quot_fm_def</span><span> </span><span>wf_dbfm_iff_is_fm</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>VarNonOccForm_dbfm</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;wf_dbfm A &#10233; atom i &#9839; A &#10233; VarNonOccForm (q_Var i) &#10214;quot_dbfm A&#10215;e&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>SubstForm_subst_dbfm_eq</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>u</span><span class="delimiter">=</span><span>DBZero</span><span class="delimiter">]</span><span> 
</span><span>    </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>VarNonOccForm_def</span><span> </span><span>Const_0</span><span> </span><span>Const_imp_Term</span><span> </span><span>fresh_iff_non_subst_dbfm</span><span> </span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>fresh_imp_VarNonOccForm</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>A</span><span class="delimiter">::</span><span>fm</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom i &#9839; A &#10233; VarNonOccForm (q_Var i) &#10214;&#171;A&#187;&#10215;e&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>quot_fm_def</span><span> </span><span>wf_dbfm_trans_fm</span><span> </span><span>VarNonOccForm_dbfm</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>VarNonOccFormP.simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span></pre>

</div>
</body>
</html>
