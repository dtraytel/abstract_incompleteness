<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Abstract_First_Godel (Isabelle2020-RC3: March 2020)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Abstract_First_Godel</h1>

<span class="command">theory</span> <span class="name">Abstract_First_Godel</span><br/>
<span class="keyword">imports</span> <a href="Godel_Formula.html"><span class="name">Godel_Formula</span></a> <a href="Standard_Model.html"><span class="name">Standard_Model</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Abstract_First_Godel</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Godel_Formula</span><span> </span><span>Standard_Model</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span> 
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Here we prove half of (the abstract version of) Godel&#39;s first theorem, 
which only needs the fixpoint property of the Godel formula *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Godel_Form</span><span> 
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* First the &quot;direct&quot;, positive formulation: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>godel_first_theEasyHalf_pos</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prv &#966;G&quot;</span></span></span><span>   </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prv fls&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>   
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prv (neg (PP &#10216;&#966;G&#10217;))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prv_eqv_prv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>assms</span><span> </span><span>prv_&#966;G_eqv</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bprv (PP &#10216;&#966;G&#10217;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>HBL1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>&#966;G</span><span> </span><span>Fvars_&#966;G</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PP_def</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>bprv_prv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>this</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prv (PP &#10216;&#966;G&#10217;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PP</span><span> </span><span>prv_neg_fls</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>&#966;G</span><span> </span><span>enc</span><span> </span><span>in_num</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Then the more standard counterpositive formulation: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>godel_first_theEasyHalf</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">&quot;consistent &#10233; &#172; prv &#966;G&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>godel_first_theEasyHalf_pos</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>consistent_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> 
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">&#8213; &#8249;context Godel_Form&#8250;</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* The other half needs explicit proofs: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Godel_Form_Proofs</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>godel_first_theHardHalf</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>oc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#969;consistent&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; prv (neg &#966;G)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>pn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prv (neg &#966;G)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>pnn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prv (neg (neg (wrepr.PP &#10216;&#966;G&#10217;)))&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prv_eqv_imp_transi</span><span> </span><span>num</span><span> </span><span>wrepr.PP</span><span> </span><span>&#966;G</span><span> </span><span>fls</span><span> </span><span>neg</span><span> </span><span>neg_def</span><span> </span><span>prv_&#966;G_eqv</span><span> </span><span>prv_eqv_sym</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>enc</span><span> </span><span>in_num</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>c</span><span> </span><span class="delimiter">=</span><span> </span><span>&#969;consistent_implies_consistent</span><span class="delimiter">[</span><span>OF</span><span> </span><span>oc</span><span class="delimiter">]</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>np</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; prv &#966;G&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pn</span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>consistent_def3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;p &#8712; num. bprv (neg (PPf p &#10216;&#966;G&#10217;))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_prv_prv_neg_PPf</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>np</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;p &#8712; num. prv (neg (PPf p &#10216;&#966;G&#10217;))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_prv_prv_neg_PPf</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>np</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>bprv_prv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; prv (neg (neg (exi yy (PPf (Var yy) &#10216;&#966;G&#10217;))))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>0</span><span> </span><span>oc</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>&#969;consistent_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; prv (neg (neg (wrepr.PP &#10216;&#966;G&#10217;)))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrepr.PP_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>P_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>  </span><span>PPf_def2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pnn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>godel_first</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#969;consistent&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; prv &#966;G &#8743; &#172; prv (neg &#966;G)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>godel_first_theEasyHalf</span><span> </span><span>godel_first_theHardHalf</span><span> </span><span>&#969;consistent_implies_consistent</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>godel_first_ex</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#969;consistent&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707; &#966;. &#966; &#8712; fmla &#8743; &#172; prv &#966; &#8743; &#172; prv (neg &#966;)&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>godel_first</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>&#966;G</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">&#8213; &#8249;context Godel_Form_Proofs&#8250;</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* THE MODEL-THEORETIC VERSION *)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(********************************)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* The truth of the Godel sentence &#966;G in the standard model *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Godel_Form_Proofs_Minimal_Truth</span><span> </span><span class="delimiter">=</span><span> 
</span><span>Godel_Form_Proofs</span><span> 
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span> 
</span><span>  </span><span>fls</span><span> 
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span> 
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>S</span><span> 
</span><span>  </span><span>dsj</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;proof&quot;</span></span></span><span> </span><span>prfOf</span><span> </span><span>encPf</span><span> 
</span><span>  </span><span>Pf</span><span>
</span><span class="delimiter">+</span><span>
</span><span>Minimal_Truth_Soundness</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span> 
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>bprv</span><span>
</span><span>  </span><span>isTrue</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span> 
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;var set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;trm set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;fmla set&quot;</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>  
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span> 
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fls</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dsj</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>num</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span>bprv</span><span>   
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enc</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;_&#10217;&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S</span><span> 
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;proof&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;proof set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prfOf</span><span> </span><span>encPf</span><span> 
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Pf</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>isTrue</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>   
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Recall that consistent and &#969;consistent refer to prv. *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>isTrue_&#966;G</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;consistent&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;isTrue &#966;G&quot;</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704; n &#8712; num. bprv (neg (PPf n &#10216;&#966;G&#10217;))&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_prv_prv_neg_PPf</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>godel_first_theEasyHalf</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704; n &#8712; num. isTrue (neg (PPf n &#10216;&#966;G&#10217;))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>bprv_sound_isTrue</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;isTrue (all yy (neg (PPf (Var yy) &#10216;&#966;G&#10217;)))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>isTrue_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;isTrue (imp (all yy (neg (PPf (Var yy) &#10216;&#966;G&#10217;))) &#966;G)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bprv_eqv_all_not_PPf_imp_&#966;G</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>bprv_sound_isTrue</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>isTrue_imp</span><span class="delimiter">[</span><span>rotated</span><span> </span><span>-</span><span>2</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Now we have (for sound theories) the strong form of Godel&#39;s first, which 
concludes the truth of the Godel sentence &#966;G: *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>godel_first_strong</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">&quot;&#969;consistent &#10233; &#172; prv &#966;G &#8743; &#172; prv (neg &#966;G) &#8743; isTrue &#966;G&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>godel_first</span><span> </span><span>isTrue_&#966;G</span><span> </span><span>&#969;consistent_implies_consistent</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>godel_first_strong_ex</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">&quot;&#969;consistent &#10233; &#8707; &#966;. &#966; &#8712; fmla &#8743; &#172; prv &#966; &#8743; &#172; prv (neg &#966;) &#8743; isTrue &#966;&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>godel_first_strong</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>&#966;G</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">&#8213; &#8249;context Godel_Form_Proofs_Minimal_Truth&#8250;</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Godel_Form_Minimal_Truth_Soundness_HBL1iff_Compl_Pf</span><span> </span><span class="delimiter">=</span><span> 
</span><span>Godel_Form</span><span> 
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>num</span><span> 
</span><span>  </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span> 
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span> 
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>S</span><span> 
</span><span>  </span><span>P</span><span> 
</span><span class="delimiter">+</span><span>  
</span><span>Minimal_Truth_Soundness_HBL1iff_Compl_Pf</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span> 
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>P</span><span>
</span><span>  </span><span>isTrue</span><span>
</span><span>  </span><span>Pf</span><span>   
</span><span class="keyword2"><span class="keyword">for</span></span><span> 
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;var set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;trm set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;fmla set&quot;</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>  
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span> 
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fls</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dsj</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>num</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span>bprv</span><span> 
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enc</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;_&#10217;&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S</span><span> 
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>isTrue</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Pf</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Godel_Form_Minimal_Truth_Soundness_HBL1iff_Compl_Pf_Compl_NegPf</span><span> </span><span class="delimiter">=</span><span> 
</span><span>Godel_Form_Minimal_Truth_Soundness_HBL1iff_Compl_Pf</span><span> 
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>  
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span> 
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>enc</span><span> 
</span><span>  </span><span>S</span><span> 
</span><span>  </span><span>isTrue</span><span>
</span><span>  </span><span>P</span><span>
</span><span>  </span><span>Pf</span><span>
</span><span class="delimiter">+</span><span>
</span><span>Minimal_Truth_Soundness_HBL1iff_Compl_Pf_Compl_NegPf</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>  
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span> 
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>enc</span><span>  
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>P</span><span>
</span><span>  </span><span>isTrue</span><span>
</span><span>  </span><span>Pf</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span> 
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;var set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;trm set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;fmla set&quot;</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>  
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span> 
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fls</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dsj</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>num</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span>bprv</span><span>  
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enc</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;_&#10217;&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S</span><span> 
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>isTrue</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Pf</span><span> 
</span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>prv_&#969;consistent</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#969;consistent&quot;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Semantic Godel&#39;s first, Godel-style, second variant 
... established as a sublocale statement *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> 
</span><span>  </span><span>Godel_Form_Minimal_Truth_Soundness_HBL1iff_Compl_Pf_Compl_NegPf</span><span> </span><span class="delimiter">&lt;</span><span> 
</span><span>  </span><span>recover_proofs</span><span class="delimiter">:</span><span> </span><span>Godel_Form_Proofs_Minimal_Truth</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>prfOf</span><span> </span><span class="delimiter">=</span><span> </span><span>prfOf</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;proof&quot;</span></span></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;proof&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>encPf</span><span> </span><span class="delimiter">=</span><span> </span><span>encPf</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span class="delimiter">=</span><span> </span><span>prv</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bprv</span><span> </span><span class="delimiter">=</span><span> </span><span>bprv</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span>  
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* ... and here is the explicit statement, inside the locale that 
provides all the assumptions *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Godel_Form_Minimal_Truth_Soundness_HBL1iff_Compl_Pf_Compl_NegPf</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>recover_proofs.godel_first_strong</span><span> 
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* *)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* THE CLASSICAL VERSION: *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(**************************************)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* To further obtain that the Godel formula is true, Classic takes advantage of Minimal_Truth_Soundness 
(w.r.t. a standard model) 
together with the fact that the truth of P &#10216;&#966;&#10217; implies the provability of &#966;: 
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Godel_Form_Classical_HBL1_rev_prv</span><span> </span><span class="delimiter">=</span><span>  
</span><span>Godel_Form</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>num</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span> 
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span> 
</span><span>  </span><span>enc</span><span> 
</span><span>  </span><span>S</span><span> 
</span><span>  </span><span>P</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span> 
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;var set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;trm set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;fmla set&quot;</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>num</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fls</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span>bprv</span><span> 
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enc</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;_&#10217;&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P</span><span>
</span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> 
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*NB: we don&#39;t really need to assume classical reasoning 
(double negation) all throughout, 
but only for the provability predicate: *)</span></span></span></span></span><span>
</span><span>classical_P_prv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896; &#966;. &#966; &#8712; fmla &#10233; Fvars &#966; = {} &#10233; let PP = (&#955;t. subst P t xx) in 
  prv (neg (neg (PP &#10216;&#966;&#10217;))) &#10233; prv (PP &#10216;&#966;&#10217;)&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>HBL1_rev_prv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896; &#966;. &#966; &#8712; fmla &#10233; Fvars &#966; = {} &#10233; prv (PP &#10216;&#966;&#10217;) &#10233; prv &#966;&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HBL1_rev</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#966; &#8712; fmla&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Fvars &#966; = {}&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bprv (PP &#10216;&#966;&#10217;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prv &#966;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>HBL1_rev_prv</span><span> </span><span>bprv_prv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>bp</span><span class="delimiter">]</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>classical_PP_prv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#966; &#8712; fmla &#10233; Fvars &#966; = {} &#10233; prv (neg (neg (PP &#10216;&#966;&#10217;))) &#10233; prv (PP &#10216;&#966;&#10217;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>classical_P_prv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PP_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HBL1_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#966; &#8712; fmla &#10233; Fvars &#966; = {} &#10233; bprv (PP &#10216;&#966;&#10217;) &#10231; prv &#966;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>HBL1</span><span> </span><span>HBL1_rev</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PP_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HBL1_iff_prv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#966; &#8712; fmla &#10233; Fvars &#966; = {} &#10233; prv (PP &#10216;&#966;&#10217;) &#10231; prv &#966;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>HBL1_PP</span><span> </span><span>HBL1_rev_prv</span><span> </span><span>PP</span><span> </span><span>d_dwf.bprv_prv&#39;</span><span> </span><span>enc</span><span> </span><span>in_num</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>godel_first_theHardHalf_pos</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prv (neg &#966;G)&quot;</span></span></span><span>   </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prv fls&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prv (neg (neg (PP &#10216;&#966;G&#10217;)))&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>neg_def</span><span> </span><span>prv_&#966;G_eqv</span><span> </span><span>prv_eqv_imp_transi_rev</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prv (PP &#10216;&#966;G&#10217;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>classical_PP_prv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prv &#966;G&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Fvars_&#966;G</span><span> </span><span>HBL1_rev_prv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>prv_neg_fls</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>  
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Then the more standard counterpositive formulation: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>godel_first_theHardHalf</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">&quot;consistent &#10233; &#172; prv (neg &#966;G)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>godel_first_theHardHalf_pos</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>consistent_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>godel_first_classic</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;consistent&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; prv &#966;G &#8743; &#172; prv (neg &#966;G)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>godel_first_theEasyHalf</span><span> </span><span>godel_first_theHardHalf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>godel_first_classic_ex</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;consistent&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707; &#966;. &#966; &#8712; fmla &#8743; &#172; prv &#966; &#8743; &#172; prv (neg &#966;)&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>godel_first_classic</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>&#966;G</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">&#8213; &#8249;Godel_Form_Classical_HBL1_rev_prv&#8250;</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Godel_Form_Classical_HBL1_rev_prv_Minimal_Truth_Soundness_TIP</span><span> </span><span class="delimiter">=</span><span>  
</span><span>Godel_Form_Classical_HBL1_rev_prv</span><span> 
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>num</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span> 
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span> 
</span><span>  </span><span>enc</span><span> 
</span><span>  </span><span>S</span><span> 
</span><span>  </span><span>P</span><span>
</span><span class="delimiter">+</span><span>
</span><span>Minimal_Truth_Soundness</span><span> 
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span> 
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>bprv</span><span> 
</span><span>  </span><span>isTrue</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span> 
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;var set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;trm set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;fmla set&quot;</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>num</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>dsj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fls</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enc</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;_&#10217;&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>isTrue</span><span>
</span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> 
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Truth of &#966; implies provability of (the internal representation of) &#966; *)</span></span></span></span></span><span>
</span><span>TIP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896; &#966;. &#966; &#8712; fmla &#10233; Fvars &#966; = {} &#10233; 
  let PP = (&#955;t. subst P t xx) in 
  isTrue (PP &#10216;&#966;&#10217;) &#10233; prv &#966;&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>TIP_PP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#966; &#8712; fmla &#10233; Fvars &#966; = {} &#10233; isTrue (PP &#10216;&#966;&#10217;) &#10233; prv &#966;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>TIP</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PP_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>isTrue_&#966;G</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>consistent</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;isTrue &#966;G&quot;</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; isTrue &#966;G&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;isTrue (neg &#966;G)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>isTrue_neg</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bprv (imp (neg &#966;G) (neg (neg (PP &#10216;&#966;G&#10217;))))&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bprv_&#966;G_eqv</span><span> </span><span>B.prv_imp_eqvER</span><span> </span><span>B.prv_imp_neg_rev</span><span class="delimiter">)</span><span>   
</span><span>   </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>prv_imp_implies_isTrue</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>this</span><span> </span><span>1</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;isTrue (neg (neg (PP &#10216;&#966;G&#10217;)))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>isTrue_neg_neg</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>this</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;isTrue (PP &#10216;&#966;G&#10217;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prv &#966;G&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>TIP_PP</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>godel_first_classic</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>godel_first_classic_strong</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;consistent &#10233; &#172; prv &#966;G &#8743; &#172; prv (neg &#966;G) &#8743; isTrue &#966;G&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>godel_first_classic</span><span> </span><span>isTrue_&#966;G</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>godel_first_classic_strong_ex</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">&quot;consistent &#10233; &#8707; &#966;. &#966; &#8712; fmla &#8743; &#172; prv &#966; &#8743; &#172; prv (neg &#966;) &#8743; isTrue &#966;&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>godel_first_classic_strong</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>&#966;G</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>blast</span><span> 
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">&#8213; &#8249;locale Godel_Form_Classical_HBL1_rev_prv_Minimal_Truth_Soundness_TIP&#8250;</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Godel_Form</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">print_context</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Godel_Form_Minimal_Truth_Soundness_HBL1iff_prv_Compl_Pf_Classical</span><span> </span><span class="delimiter">=</span><span> 
</span><span>Godel_Form</span><span> 
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>num</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>  
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span> 
</span><span>  </span><span>fls</span><span> 
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span> 
</span><span>  </span><span>enc</span><span> 
</span><span>  </span><span>S</span><span>  
</span><span>  </span><span>P</span><span> 
</span><span class="delimiter">+</span><span>
</span><span>Minimal_Truth_Soundness_HBL1iff_prv_Compl_Pf_Classical</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>  
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span> 
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>enc</span><span>  
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>P</span><span>
</span><span>  </span><span>isTrue</span><span>
</span><span>  </span><span>Pf</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span> 
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;var set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;trm set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;fmla set&quot;</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>  
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span> 
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fls</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dsj</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>num</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span>bprv</span><span>  
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enc</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;_&#10217;&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S</span><span> 
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>isTrue</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Pf</span><span> 
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>Godel_Form_Minimal_Truth_Soundness_HBL1iff_prv_Compl_Pf_Classical</span><span> </span><span class="delimiter">&lt;</span><span> 
</span><span>  </span><span>recover_proofs</span><span class="delimiter">:</span><span> </span><span>Godel_Form_Classical_HBL1_rev_prv_Minimal_Truth_Soundness_TIP</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>prv</span><span> </span><span class="delimiter">=</span><span> </span><span>prv</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bprv</span><span> </span><span class="delimiter">=</span><span> </span><span>bprv</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span> </span><span>classical</span><span> </span><span>rev_rpv</span><span> </span><span>TIPf</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>classical</span><span> </span><span>&#966;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>HBL1_iff</span><span> </span><span>classical_P</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mts_prv_mts.PP_deff</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>rev_rpv</span><span> </span><span>&#966;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>HBL1_iff_prv</span><span> </span><span>PP_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>TIPf</span><span> </span><span>&#966;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>classical_P</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>SS_def</span><span> </span><span>PP_def</span><span> </span><span>mts_prv_mts.TIP</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Godel_Form_Minimal_Truth_Soundness_HBL1iff_prv_Compl_Pf_Classical</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>recover_proofs.godel_first_classic_strong</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* context Godel_Form_Minimal_Truth_Soundness_HBL1iff_Compl_Pf_Classical *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>

</div>
</body>
</html>
