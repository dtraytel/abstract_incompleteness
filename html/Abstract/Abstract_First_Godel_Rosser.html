<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Abstract_First_Godel_Rosser (Isabelle2020-RC3: March 2020)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Abstract_First_Godel_Rosser</h1>

<span class="command">theory</span> <span class="name">Abstract_First_Godel_Rosser</span><br/>
<span class="keyword">imports</span> <a href="Rosser_Formula.html"><span class="name">Rosser_Formula</span></a> <a href="Standard_Model.html"><span class="name">Standard_Model</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Abstract_First_Godel_Rosser</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Rosser_Formula</span><span> </span><span>Standard_Model</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Rosser_Form_Proofs</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NN_neg_unique_xx&#39;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#966; &#8712; fmla&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Fvars &#966; = {}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;bprv (imp (NN &#10216;&#966;&#10217; (Var xx&#39;))  
          (eql &#10216;neg &#966;&#10217; (Var xx&#39;)))&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B.prv_subst</span><span class="delimiter">[</span><span>of</span><span> </span><span>yy</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Var xx&#39;&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>NN_neg_unique</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NN_imp_xx&#39;</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#966; &#8712; fmla&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Fvars &#966; = {}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#967; &#8712; fmla&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bprv (imp (subst &#967; &#10216;neg &#966;&#10217; xx&#39;)
                   (all xx&#39; (imp (NN &#10216;&#966;&#10217; (Var xx&#39;)) &#967;)))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bprv (imp (eql &#10216;neg &#966;&#10217; (Var xx&#39;)) (imp (subst &#967; &#10216;neg &#966;&#10217; xx&#39;) &#967;))&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B.prv_eql_subst_trm</span><span class="delimiter">[</span><span>of</span><span> </span><span>xx&#39;</span><span> </span><span>&#967;</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;neg &#966;&#10217;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Var xx&#39;&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bprv (imp (subst &#967; &#10216;neg &#966;&#10217; xx&#39;) (imp (eql &#10216;neg &#966;&#10217; (Var xx&#39;)) &#967;))&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;2&quot;</span></span></span><span> </span><span>B.prv_imp_com</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bprv (imp (subst &#967; &#10216;neg &#966;&#10217; xx&#39;) (imp (NN &#10216;&#966;&#10217; (Var xx&#39;)) &#967;))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span>NN_neg_unique_xx&#39;</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>NN</span><span> </span><span>Var</span><span> </span><span>assms</span><span> </span><span>enc</span><span> </span><span>eql</span><span> </span><span>imp</span><span> </span><span>in_num</span><span> </span><span>subst</span><span> </span><span>neg</span><span> </span><span>B.prv_imp_com</span><span> </span><span>B.prv_prv_imp_trans</span><span> </span><span>xx&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>B.prv_all_imp_gen</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Fvars_subst</span><span> </span><span>0</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>godel_rosser_first_theEasyHalf</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;consistent&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; prv &#966;R&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prv &#966;R&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prf&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prf &#8712; proof&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prfOf prf &#966;R&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prv_prfOf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>00</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bprv (PPf (encPf prf) &#10216;&#966;R&#10217;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prfOf_PPf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>dwf_dwfd.d_dwf.bprv_prv&#39;</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>00</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b00</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prv (PPf (encPf prf) &#10216;&#966;R&#10217;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; prv (neg &#966;R)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>0</span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>consistent_def3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704; prf &#8712; proof.  &#172; prfOf prf (neg &#966;R)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>00</span><span> </span><span>prv_prfOf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bprv (neg (PPf p &#10216;neg &#966;R&#10217;))&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;p &#8712; num&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_prfOf_PPf</span><span> </span><span>PPf_encPf</span><span> </span><span>that</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;p &#8712; encPf ` proof&quot;</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prv (all zz (imp (LLq (Var zz) (encPf prf)) (neg (PPf (Var zz) &#10216;neg &#966;R&#10217;))))&quot;</span></span></span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* here use locale assumption about the order-like relation: *)</span></span></span></span></span><span>   
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>LLq_num</span><span class="delimiter">)</span><span> </span><span>auto</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>11</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prv (RR (encPf prf) &#10216;&#966;R&#10217;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NN_imp_xx&#39;</span><span class="delimiter">[</span><span>of</span><span> </span><span>&#966;R</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;neg (PPf (Var zz) (Var xx&#39;))&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>RR_def2</span><span> </span><span>R_def</span><span>
</span><span>      </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>prv_all_congW</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>1</span><span class="delimiter">]</span><span> </span><span>prv_imp_monoL</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>dwf_dwfd.d_dwf.bprv_prv&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prv (cnj (PPf (encPf prf) &#10216;&#966;R&#10217;) (RR (encPf prf) &#10216;&#966;R&#10217;))&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>prv_cnjI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>b00</span><span> </span><span>11</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prv ((PP&#39; &#10216;&#966;R&#10217;))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PP&#39;_def</span><span> </span><span>P&#39;_def</span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>prv_exiI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;encPf prf&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prv (neg (PP&#39; &#10216;&#966;R&#10217;))&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prv_eqv_prv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>0</span><span> </span><span>prv_&#966;R_eqv</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>consistent_def3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>godel_rosser_first_theHardHalf</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;consistent&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; prv (neg &#966;R)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prv (neg &#966;R)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prf&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prf &#8712; proof&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prfOf prf (neg &#966;R)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prv_prfOf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>p</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;p = encPf prf&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;p &#8712; num&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>11</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bprv (PPf p &#10216;neg &#966;R&#10217;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pr</span><span> </span><span>prfOf_PPf</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bprv (NN &#10216;&#966;R&#10217; &#10216;neg &#966;R&#10217;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NN_neg</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; prv &#966;R&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>0</span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>consistent_def3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>not_prv_prv_neg_PPf</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>this</span><span class="delimiter">]</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704; r &#8712; num. bprv (neg (PPf r &#10216;&#966;R&#10217;))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704; r &#8712; num. prv (neg (PPf r &#10216;&#966;R&#10217;))&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>dwf_dwfd.d_dwf.bprv_prv&#39;</span><span class="delimiter">)</span><span>  
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>P</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8838;num&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite P&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prv (dsj (sdsj {eql (Var yy) r |r. r &#8712; P}) (LLq p (Var yy)))&quot;</span></span></span><span> 
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* here use the other locale assumption about the order-like relation: *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LLq_num2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prv (imp (cnj (PPf (Var yy) &#10216;&#966;R&#10217;) (RR (Var yy) &#10216;&#966;R&#10217;)) fls)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>prv_dsj_cases</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>3</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>r</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r &#8712; P&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>rn</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r &#8712; num&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>P</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prv (imp (cnj (PPf r &#10216;&#966;R&#10217;) (RR r &#10216;&#966;R&#10217;)) fls)&quot;</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>neg_def</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>FvarsT_num</span><span> </span><span>PPf</span><span> </span><span>RR</span><span> </span><span>rn</span><span> </span><span>&#966;R</span><span> </span><span>all_not_in_conv</span><span> </span><span>cnj</span><span> </span><span>enc</span><span> </span><span>fls</span><span> </span><span>imp</span><span> </span><span>in_num</span><span> </span><span>prv_imp_cnj3L</span><span> </span><span>prv_imp_mp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prv (imp (eql (Var yy) r) 
                (imp (cnj (PPf (Var yy) &#10216;&#966;R&#10217;) (RR (Var yy) &#10216;&#966;R&#10217;)) fls))&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prv_eql_subst_trm_id</span><span class="delimiter">[</span><span>of</span><span> </span><span>yy</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cnj (PPf (Var yy) &#10216;&#966;R&#10217;) (RR (Var yy) &#10216;&#966;R&#10217;)&quot;</span></span></span><span> </span><span>r</span><span class="delimiter">,</span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>neg_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>prv_neg_imp_imp_trans</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prv (imp (sdsj {eql (Var yy) r |r. r &#8712; P}) 
              (imp (cnj (PPf (Var yy) &#10216;&#966;R&#10217;) (RR (Var yy) &#10216;&#966;R&#10217;)) fls))&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Var</span><span> </span><span>P</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>eql</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>prv_sdsj_imp</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>0</span><span> </span><span>0</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>set_rev_mp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?&#966;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;all xx&#39; (imp (NN &#10216;&#966;R&#10217; (Var xx&#39;)) (neg (PPf p (Var xx&#39;))))&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bprv (neg ?&#966;)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span>11</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>B.prv_imp_neg_allWI</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;neg &#966;R&#10217;&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>B.prv_prv_neg_imp_neg</span><span class="delimiter">)</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prv (neg ?&#966;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>dwf_dwfd.d_dwf.bprv_prv&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>00</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prv (imp (LLq p (Var yy))
                       (imp (imp (LLq p (Var yy)) ?&#966;) fls))&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>neg_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>prv_imp_neg_imp_neg_imp</span><span class="delimiter">)</span><span> </span><span>auto</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prv (imp (LLq p (Var yy)) 
              (imp (RR (Var yy) &#10216;&#966;R&#10217;) fls))&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>neg_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>00</span><span class="delimiter">[</span><span>folded</span><span> </span><span>neg_def</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>RR_def2</span><span> </span><span>R_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>prv_imp_neg_allI</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t</span><span> </span><span class="delimiter">=</span><span> </span><span>p</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prv (imp (LLq p (Var yy)) 
              (imp (cnj (PPf (Var yy) &#10216;&#966;R&#10217;) (RR (Var yy) &#10216;&#966;R&#10217;)) fls))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>neg_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>prv_imp_neg_imp_cnjR</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">,</span><span> </span><span>insert</span><span> </span><span>Var</span><span> </span><span>P</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>eql</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>set_rev_mp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prv (neg (exi yy (cnj (PPf (Var yy) &#10216;&#966;R&#10217;) (RR (Var yy) &#10216;&#966;R&#10217;))))&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>neg_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>prv_neg_neg_exi</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prv (neg (PP&#39; &#10216;&#966;R&#10217;))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PP&#39;_def</span><span> </span><span>P&#39;_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prv &#966;R&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prv_&#966;R_eqv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>PP&#39;</span><span> </span><span>&#966;R</span><span> </span><span>enc</span><span> </span><span>in_num</span><span> </span><span>neg</span><span> </span><span>prv_eqv_prv_rev</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`&#172; prv &#966;R`</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>consistent_def3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>godel_rosser_first</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;consistent&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; prv &#966;R &#8743; &#172; prv (neg &#966;R)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>godel_rosser_first_theEasyHalf</span><span> </span><span>godel_rosser_first_theHardHalf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>godel_rosser_first_ex</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;consistent&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707; &#966;. &#966; &#8712; fmla &#8743; &#172; prv &#966; &#8743; &#172; prv (neg &#966;)&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>godel_rosser_first</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>&#966;R</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">&#8213; &#8249;context Rosser_Form&#8250;</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* THE MODEL-THEORETIC VERSION *)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(********************************)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* The truth of the Rosser sentence &#966;R in the standard model 
is proved very similarly to that of the Godel setnece &#966;R *)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Rosser_Form_Proofs_Minimal_Truth</span><span> </span><span class="delimiter">=</span><span> 
</span><span>Rosser_Form_Proofs</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span> 
</span><span>  </span><span>fls</span><span> 
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span> 
</span><span>  </span><span>Lq</span><span> 
</span><span>  </span><span>dsj</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;proof&quot;</span></span></span><span> </span><span>prfOf</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>N</span><span> </span><span>S</span><span>   
</span><span>  </span><span>encPf</span><span> 
</span><span>  </span><span>Pf</span><span> 
</span><span class="delimiter">+</span><span>
</span><span>Minimal_Truth_Soundness</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span> 
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>bprv</span><span>
</span><span>  </span><span>isTrue</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span> 
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;var set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;trm set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;fmla set&quot;</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>  
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span> 
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fls</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dsj</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>num</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Lq</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span>bprv</span><span>   
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enc</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;_&#10217;&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>N</span><span> </span><span>S</span><span> </span><span>P</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;proof&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;proof set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prfOf</span><span> </span><span>encPf</span><span> 
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Pf</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>isTrue</span><span> 
</span><span class="keyword2"><span class="keyword">begin</span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Fvars_PP&#39;</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Fvars (PP&#39; &#10216;&#966;R&#10217;) = {}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PP&#39;_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>Fvars_subst</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Fvars_RR&#39;</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Fvars (RR (Var yy) &#10216;&#966;R&#10217;) = {yy}&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>RR_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>Fvars_psubst</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{yy}&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isTrue_PPf_implies_&#966;R</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;isTrue (all yy (neg (PPf (Var yy) &#10216;&#966;R&#10217;)))&quot;</span></span></span><span>
</span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;isTrue ?H&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;isTrue &#966;R&quot;</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>  
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>F</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;F &#8801; RR (Var yy) &#10216;&#966;R&#10217;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;F &#8712; fmla&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Fvars F = {yy}&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>F_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;exi yy (PPf (Var yy) &#10216;&#966;R&#10217;) &#8712; fmla&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PPf_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bprv
     (imp (all yy (neg (PPf (Var yy) &#10216;&#966;R&#10217;)))
       (neg (exi yy (PPf (Var yy) &#10216;&#966;R&#10217;))))&quot;</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bprv (imp (all yy (neg ?G)) (neg (exi yy ?G)))&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B.prv_all_neg_imp_neg_exi</span><span class="delimiter">[</span><span>of</span><span> </span><span>yy</span><span> </span><span class="var">?G</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bprv (imp (neg (exi yy ?G)) (neg (exi yy (cnj ?G F))))&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>B.prv_imp_neg_rev</span><span> </span><span>B.prv_exi_cong</span><span> </span><span>B.prv_imp_cnjL</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bprv (imp (all yy (neg ?G)) (neg (exi yy (cnj ?G F))))&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B.prv_prv_imp_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span>  </span><span>1</span><span> </span><span>2</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bprv (imp ?H (neg (PP&#39; &#10216;&#966;R&#10217;)))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PP&#39;_def</span><span> </span><span>P&#39;_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>F_def</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>B.prv_prv_imp_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span>  </span><span>this</span><span> </span><span>bprv_imp_&#966;R</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bprv (imp ?H &#966;R)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>   
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>prv_imp_implies_isTrue</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>this</span><span> </span><span>assms</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>     
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>isTrue_&#966;R</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;consistent&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;isTrue &#966;R&quot;</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>   
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704; n &#8712; num. bprv (neg (PPf n &#10216;&#966;R&#10217;))&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_prv_prv_neg_PPf</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>godel_rosser_first_theEasyHalf</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704; n &#8712; num. isTrue (neg (PPf n &#10216;&#966;R&#10217;))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>bprv_sound_isTrue</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;isTrue (all yy (neg (PPf (Var yy) &#10216;&#966;R&#10217;)))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>isTrue_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>isTrue_PPf_implies_&#966;R</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Now we have (for sound theories) the strong form of Rosser&#39;s first, which 
concludes the truth of the Rosser sentence &#966;R: *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>godel_rosser_first_strong</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;consistent &#10233; &#172; prv &#966;R &#8743; &#172; prv (neg &#966;R) &#8743; isTrue &#966;R&quot;</span></span></span><span>   
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>isTrue_&#966;R</span><span> </span><span>godel_rosser_first</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>godel_rosser_first_strong_ex</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">&quot;consistent &#10233; &#8707; &#966;. &#966; &#8712; fmla &#8743; &#172; prv &#966; &#8743; &#172; prv (neg &#966;) &#8743; isTrue &#966;&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>godel_rosser_first_strong</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>&#966;R</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">&#8213; &#8249;Rosser_Form_Proofs_Minimal_Truth&#8250;</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Rosser_Form</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span> 
</span><span class="keyword1"><span class="command">print_context</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Rosser_Form_Minimal_Truth_Soundness_HBL1iff_Compl_Pf</span><span> </span><span class="delimiter">=</span><span> 
</span><span>Rosser_Form</span><span> 
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span>  
</span><span>  </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span> 
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span> 
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span> 
</span><span>  </span><span>Lq</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>N</span><span>
</span><span>  </span><span>S</span><span> 
</span><span>  </span><span>P</span><span>   
</span><span class="delimiter">+</span><span>  
</span><span>Minimal_Truth_Soundness_HBL1iff_Compl_Pf</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span> 
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>P</span><span>
</span><span>  </span><span>isTrue</span><span>
</span><span>  </span><span>Pf</span><span>   
</span><span class="keyword2"><span class="keyword">for</span></span><span>  
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;var set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;trm set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;fmla set&quot;</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>  
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span> 
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fls</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dsj</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>num</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span>bprv</span><span> 
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Lq</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enc</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;_&#10217;&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>N</span><span> </span><span>S</span><span> 
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>isTrue</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P</span><span> </span><span>Pf</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Rosser_Form_Minimal_Truth_Soundness_HBL1iff_Compl_Pf_Compl_NegPf</span><span> </span><span class="delimiter">=</span><span> 
</span><span>Rosser_Form_Minimal_Truth_Soundness_HBL1iff_Compl_Pf</span><span> 
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>  
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span> 
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>Lq</span><span>
</span><span>  </span><span>enc</span><span> 
</span><span>  </span><span>N</span><span> </span><span>S</span><span> 
</span><span>  </span><span>isTrue</span><span>
</span><span>  </span><span>P</span><span>
</span><span>  </span><span>Pf</span><span>
</span><span class="delimiter">+</span><span>
</span><span>M</span><span> </span><span class="delimiter">:</span><span> </span><span>Minimal_Truth_Soundness_HBL1iff_Compl_Pf_Compl_NegPf</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>  
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span> 
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>enc</span><span>  
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>N</span><span> 
</span><span>  </span><span>isTrue</span><span>
</span><span>  </span><span>Pf</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span> 
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;var set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;trm set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;fmla set&quot;</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>  
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span> 
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fls</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dsj</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>num</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span>bprv</span><span>  
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Lq</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enc</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;_&#10217;&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>N</span><span> </span><span>S</span><span> </span><span>P</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>isTrue</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Pf</span><span> 
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Semantic Godel&#39;s first, Godel-style, second variant 
... established as a sublocale statement *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> 
</span><span>  </span><span>Rosser_Form_Minimal_Truth_Soundness_HBL1iff_Compl_Pf_Compl_NegPf</span><span> </span><span class="delimiter">&lt;</span><span> 
</span><span>  </span><span>recover_proofs</span><span class="delimiter">:</span><span> </span><span>Rosser_Form_Proofs_Minimal_Truth</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>prfOf</span><span> </span><span class="delimiter">=</span><span> </span><span>prfOf</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;proof&quot;</span></span></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;proof&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>encPf</span><span> </span><span class="delimiter">=</span><span> </span><span>encPf</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span class="delimiter">=</span><span> </span><span>prv</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bprv</span><span> </span><span class="delimiter">=</span><span> </span><span>bprv</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span>  
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* ... and here is the explicit statement, inside the locale that 
provides all the assumptions *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Rosser_Form_Minimal_Truth_Soundness_HBL1iff_Compl_Pf_Compl_NegPf</span><span> 
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>recover_proofs.godel_rosser_first_strong</span><span> 
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span></pre>

</div>
</body>
</html>
