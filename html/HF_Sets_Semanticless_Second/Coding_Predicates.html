<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Coding_Predicates (Isabelle2020-RC3: March 2020)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Coding_Predicates</h1>

<span class="command">theory</span> <span class="name">Coding_Predicates</span><br/>
<span class="keyword">imports</span> <a href="Coding.html"><span class="name">Coding</span></a> <a href="Sigma.html"><span class="name">Sigma</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">chapter</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*Predicates for Terms, Formulas and Substitution*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Coding_Predicates</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Coding</span><span> </span><span>Sigma</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>succ_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*This material comes from Section 3, greatly modified for de Bruijn syntax.*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*Predicates for atomic terms*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*Free Variables*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>VarP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; fm&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;VarP x &#8801; OrdP x AND Zero IN x&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>VarP_eqvt</span><span> </span><span class="delimiter">[</span><span>eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(p &#8729; VarP x) = VarP (p &#8729; x)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>VarP_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>VarP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; VarP x &#10231; a &#9839; x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>VarP_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>VarP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (VarP x)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>VarP_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>VarP_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(VarP x)(i::=t) = VarP (subst i t x) &quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>VarP_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>VarP_cong</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; x EQ x&#39; &#10233; H &#8866; VarP x IFF VarP x&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>P1_cong</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>VarP_HPairE</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insert (VarP (HPair x y)) H &#8866; A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>VarP_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*De Bruijn Indexes*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>Q_Ind</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; tm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Q_Ind k &#8801; HPair (HTuple 6) k&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>IndP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom m &#9839; x &#10233;
    IndP x = Ex m (OrdP (Var m) AND x EQ HPair (HTuple 6) (Var m))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>IndP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>IndP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; IndP x &#10231; a &#9839; x&quot;</span></span></span><span>                </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>IndP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (IndP x)&quot;</span></span></span><span>                   </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thsf</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>OrdP_IndP_Q_Ind</span><span class="delimiter">:</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;{OrdP x} &#8866; IndP (Q_Ind x)&quot;</span></span></span><span>           </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thqind</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom m &#9839; x&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thsf</span><span> </span><span class="var">?thqind</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Ex_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>IndP_Q_Ind</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; OrdP x &#10233; H &#8866; IndP (Q_Ind x)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cut1</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>OrdP_IndP_Q_Ind</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subst_fm_IndP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(IndP t)(i::=x) = IndP (subst i x t)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom m &#9839; (i,t,x)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>IndP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>IndP_cong</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8866; x EQ x&#39; &#10233; H &#8866; IndP x IFF IndP x&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>P1_cong</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*Various syntactic lemmas*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*The predicate @{text SeqCTermP}, for Terms and Constants*}</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*SeqCTerm(s,k,t) &#8801; LstSeq(s,k,t) &#8743; (&#8704;l&#8712;k)[s l=0 &#8744; Var(s l)&#8744;(&#8707;m,n&#8712;l)[s l = &#10216;Eats, s m, s n&#10217;]]*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>SeqCTermP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bool &#8658; tm &#8658; tm &#8658; tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom l &#9839; (s,k,sl,m,n,sm,sn);  atom sl &#9839; (s,m,n,sm,sn);
          atom m &#9839; (s,n,sm,sn);  atom n &#9839; (s,sm,sn);
          atom sm &#9839; (s,sn);  atom sn &#9839; (s)&#10215; &#10233;
    SeqCTermP vf s k t =
      LstSeqP s k t AND
      All2 l (SUCC k) (Ex sl (HPair (Var l) (Var sl) IN s AND 
               (Var sl EQ Zero OR (if vf then VarP (Var sl) else Fls) OR
                Ex m (Ex n (Ex sm (Ex sn (Var m IN Var l AND Var n IN Var l AND
                       HPair (Var m) (Var sm) IN s AND HPair (Var n) (Var sn) IN s AND
                       Var sl EQ Q_Eats (Var sm) (Var sn))))))))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>SeqCTermP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>SeqCTermP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; SeqCTermP vf s k t &#10231; a &#9839; s &#8743; a &#9839; k &#8743; a &#9839; t&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SeqCTermP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (SeqCTermP vf s k t)&quot;</span></span></span><span>   </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thsf</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SeqCTermP_imp_LstSeqP</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;{ SeqCTermP vf s k t } &#8866; LstSeqP s k t&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thlstseq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SeqCTermP_imp_OrdP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;{ SeqCTermP vf s k t } &#8866; OrdP k&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thord</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sm</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sn</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>atoms</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom l &#9839; (s,k,sl,m,n,sm,sn)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom sl &#9839; (s,m,n,sm,sn)&quot;</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;atom m &#9839; (s,n,sm,sn)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom n &#9839; (s,sm,sn)&quot;</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;atom sm &#9839; (s,sn)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom sn &#9839; (s)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thsf</span><span> </span><span class="var">?thlstseq</span><span> </span><span class="var">?thord</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>LstSeqP.simps</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SeqCTermP_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;(SeqCTermP vf s k t)(j::=w) = SeqCTermP vf (subst j w s) (subst j w k) (subst j w t)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sm</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sn</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom l &#9839; (j,w,s,k,sl,m,n,sm,sn)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom sl &#9839; (j,w,s,m,n,sm,sn)&quot;</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;atom m &#9839; (j,w,s,n,sm,sn)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom n &#9839; (j,w,s,sm,sn)&quot;</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;atom sm &#9839; (j,w,s,sn)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom sn &#9839; (j,w,s)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>SeqCTermP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>l</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>sl</span><span> </span><span>m</span><span> </span><span>n</span><span> </span><span>sm</span><span> </span><span>sn</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>SeqCTermP.simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>SeqTermP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; tm &#8658; tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SeqTermP &#8801; SeqCTermP True&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>SeqConstP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; tm &#8658; tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SeqConstP &#8801; SeqCTermP False&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SeqConstP_imp_SeqTermP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{SeqConstP s k t} &#8866; SeqTermP s k t&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sm</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sn</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom l &#9839; (s,k,t,sl,m,n,sm,sn)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom sl &#9839; (s,k,t,m,n,sm,sn)&quot;</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;atom m &#9839; (s,k,t,n,sm,sn)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom n &#9839; (s,k,t,sm,sn)&quot;</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;atom sm &#9839; (s,k,t,sn)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom sn &#9839; (s,k,t)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>SeqCTermP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>l</span><span> </span><span>s</span><span> </span><span>k</span><span> </span><span>sl</span><span> </span><span>m</span><span> </span><span>n</span><span> </span><span>sm</span><span> </span><span>sn</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ex_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;Var l&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ex_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Var sl&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>force</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Disj_I1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ex_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Var sl&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Conj_I</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Disj_I2</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ex_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Var m&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ex_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Var n&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ex_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Var sm&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ex_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Var sn&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*The predicates @{text TermP} and @{text ConstP}*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*Definition*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>CTermP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bool &#8658; tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom k &#9839; (s,t); atom s &#9839; t&#10215; &#10233;
    CTermP vf t = Ex s (Ex k (SeqCTermP vf (Var s) (Var k) t))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>CTermP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>CTermP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; CTermP vf t &#10231; a &#9839; t&quot;</span></span></span><span>            </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>CTermP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (CTermP vf t)&quot;</span></span></span><span>                      </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thsf</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>k</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span class="delimiter">::</span><span>name</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom k &#9839; (s,t)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom s &#9839; t&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thsf</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>CTermP_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(CTermP vf i)(j::=w) = CTermP vf (subst j w i)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>k</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span class="delimiter">::</span><span>name</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom k &#9839; (s,i,j,w)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom s &#9839; (i,j,w)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CTermP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>k</span><span> </span><span>s</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>TermP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TermP &#8801; CTermP True&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>ConstP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ConstP &#8801; CTermP False&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*Correctness properties for constants*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ConstP_imp_TermP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{ConstP t} &#8866; TermP t&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>k</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span class="delimiter">::</span><span>name</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom k &#9839; (s,t)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom s &#9839; t&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ex_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Var s&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ex_I</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Var k&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>SeqConstP_imp_SeqTermP</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>cut1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*Abstraction over terms*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>SeqStTermP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; tm &#8658; tm &#8658; tm &#8658; tm &#8658; tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom l &#9839; (s,k,v,i,sl,sl&#39;,m,n,sm,sm&#39;,sn,sn&#39;);
          atom sl &#9839; (s,v,i,sl&#39;,m,n,sm,sm&#39;,sn,sn&#39;); atom sl&#39; &#9839; (s,v,i,m,n,sm,sm&#39;,sn,sn&#39;);
          atom m &#9839; (s,n,sm,sm&#39;,sn,sn&#39;); atom n &#9839; (s,sm,sm&#39;,sn,sn&#39;);
          atom sm &#9839; (s,sm&#39;,sn,sn&#39;); atom sm&#39; &#9839; (s,sn,sn&#39;);
          atom sn &#9839; (s,sn&#39;); atom sn&#39; &#9839; s&#10215; &#10233;
    SeqStTermP v i t u s k =
      VarP v AND LstSeqP s k (HPair t u) AND
      All2 l (SUCC k) (Ex sl (Ex sl&#39; (HPair (Var l) (HPair (Var sl) (Var sl&#39;)) IN s AND
                (((Var sl EQ v AND Var sl&#39; EQ i) OR
                  ((IndP (Var sl) OR Var sl NEQ v) AND Var sl&#39; EQ Var sl)) OR
                Ex m (Ex n (Ex sm (Ex sm&#39; (Ex sn (Ex sn&#39; (Var m IN Var l AND Var n IN Var l AND
                       HPair (Var m) (HPair (Var sm) (Var sm&#39;)) IN s AND
                       HPair (Var n) (HPair (Var sn) (Var sn&#39;)) IN s AND
                       Var sl EQ Q_Eats (Var sm) (Var sn) AND
                       Var sl&#39; EQ Q_Eats (Var sm&#39;) (Var sn&#39;)))))))))))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>SeqStTermP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>SeqStTermP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; SeqStTermP v i t u s k &#10231; a &#9839; v &#8743; a &#9839; i &#8743; a &#9839; t &#8743; a &#9839; u &#8743; a &#9839; s &#8743; a &#9839; k&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SeqStTermP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (SeqStTermP v i t u s k)&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thsf</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SeqStTermP_imp_OrdP</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;{ SeqStTermP v i t u s k } &#8866; OrdP k&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thord</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SeqStTermP_imp_VarP</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;{ SeqStTermP v i t u s k } &#8866; VarP v&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thvar</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SeqStTermP_imp_LstSeqP</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;{ SeqStTermP v i t u s k } &#8866; LstSeqP s k (HPair t u)&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thlstseq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl&#39;</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>sm</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sm&#39;</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sn</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sn&#39;</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>atoms</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;atom l &#9839; (s,k,v,i,sl,sl&#39;,m,n,sm,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;atom sl &#9839; (s,v,i,sl&#39;,m,n,sm,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom sl&#39; &#9839; (s,v,i,m,n,sm,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;atom m &#9839; (s,n,sm,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom n &#9839; (s,sm,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;atom sm &#9839; (s,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom sm&#39; &#9839; (s,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;atom sn &#9839; (s,sn&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom sn&#39; &#9839; (s)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thsf</span><span> </span><span class="var">?thord</span><span> </span><span class="var">?thvar</span><span> </span><span class="var">?thlstseq</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>LstSeqP_OrdP</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SeqStTermP_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;(SeqStTermP v i t u s k)(j::=w) =
       SeqStTermP (subst j w v) (subst j w i) (subst j w t) (subst j w u) (subst j w s) (subst j w k)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl&#39;</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>sm</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sm&#39;</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sn</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sn&#39;</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom l &#9839; (s,k,v,i,w,j,sl,sl&#39;,m,n,sm,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sl &#9839; (s,v,i,w,j,sl&#39;,m,n,sm,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sl&#39; &#9839; (s,v,i,w,j,m,n,sm,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom m &#9839; (s,w,j,n,sm,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom n &#9839; (s,w,j,sm,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sm &#9839; (s,w,j,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom sm&#39; &#9839; (s,w,j,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sn &#9839; (s,w,j,sn&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom sn&#39; &#9839; (s,w,j)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>SeqStTermP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>l</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>sl</span><span> </span><span>sl&#39;</span><span> </span><span>m</span><span> </span><span>n</span><span> </span><span>sm</span><span> </span><span>sm&#39;</span><span> </span><span>sn</span><span> </span><span>sn&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SeqStTermP_cong</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;H &#8866; t EQ t&#39;; H &#8866; u EQ u&#39;; H &#8866; s EQ s&#39;; H &#8866; k EQ k&#39;&#10215;
   &#10233; H &#8866; SeqStTermP v i t u s k IFF SeqStTermP v i t&#39; u&#39; s&#39; k&#39;&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>P4_cong</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>tms</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;[v,i]&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fresh_Cons</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>SeqStTermP.simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*Defining the syntax: main predicate*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>AbstTermP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; tm &#8658; tm &#8658; tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom s &#9839; (v,i,t,u,k); atom k &#9839; (v,i,t,u)&#10215; &#10233;
    AbstTermP v i t u =
     OrdP i AND Ex s (Ex k (SeqStTermP v (Q_Ind i) t u (Var s) (Var k)))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>AbstTermP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>AbstTermP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; AbstTermP v i t u &#10231; a &#9839; v &#8743; a &#9839; i &#8743; a &#9839; t &#8743; a &#9839; u&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>AbstTermP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (AbstTermP v i t u)&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thsf</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>AbstTermP_imp_VarP</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;{ AbstTermP v i t u } &#8866; VarP v&quot;</span></span></span><span>   </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thvar</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>AbstTermP_imp_OrdP</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;{ AbstTermP v i t u } &#8866; OrdP i&quot;</span></span></span><span>   </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thord</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>k</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom s &#9839; (v,i,t,u,k)&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;atom k &#9839; (v,i,t,u)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thsf</span><span> </span><span class="var">?thvar</span><span> </span><span class="var">?thord</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>SeqStTermP_imp_VarP</span><span> </span><span>thin2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>AbstTermP_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;(AbstTermP v i t u)(j::=w) = AbstTermP (subst j w v) (subst j w i) (subst j w t) (subst j w u)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>k</span><span class="delimiter">::</span><span>name</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom s &#9839; (v,i,t,u,w,j,k)&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;atom k &#9839; (v,i,t,u,w,j)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>AbstTermP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>k</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>AbstTermP.simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*Substitution over terms*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*Defining the syntax*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>SubstTermP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; tm &#8658; tm &#8658; tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom s &#9839; (v,i,t,u,k); atom k &#9839; (v,i,t,u)&#10215; &#10233;
    SubstTermP v i t u = TermP i AND Ex s (Ex k (SeqStTermP v i t u (Var s) (Var k)))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>SubstTermP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>SubstTermP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; SubstTermP v i t u &#10231; a &#9839; v &#8743; a &#9839; i &#8743; a &#9839; t &#8743; a &#9839; u&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SubstTermP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (SubstTermP v i t u)&quot;</span></span></span><span>     </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thsf</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SubstTermP_imp_TermP</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;{ SubstTermP v i t u } &#8866; TermP i&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thterm</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SubstTermP_imp_VarP</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;{ SubstTermP v i t u } &#8866; VarP v&quot;</span></span></span><span>   </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thvar</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>k</span><span class="delimiter">::</span><span>name</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom s &#9839; (v,i,t,u,k)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom k &#9839; (v,i,t,u)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thsf</span><span> </span><span class="var">?thterm</span><span> </span><span class="var">?thvar</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>SeqStTermP_imp_VarP</span><span> </span><span>thin2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SubstTermP_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;(SubstTermP v i t u)(j::=w) = SubstTermP (subst j w v) (subst j w i) (subst j w t) (subst j w u)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>k</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom s &#9839; (v,i,t,u,w,j,k)&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;atom k &#9839; (v,i,t,u,w,j)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>SubstTermP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>k</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SubstTermP_cong</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;H &#8866; v EQ v&#39;; H &#8866; i EQ i&#39;; H &#8866; t EQ t&#39;; H &#8866; u EQ u&#39;&#10215;
   &#10233; H &#8866; SubstTermP v i t u IFF SubstTermP v&#39; i&#39; t&#39; u&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>P4_cong</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>SubstTermP.simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*Abstraction over formulas*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*The predicate @{text AbstAtomicP}*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>AbstAtomicP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; tm &#8658; tm &#8658; tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom t &#9839; (v,i,y,y&#39;,t&#39;,u,u&#39;); atom t&#39; &#9839; (v,i,y,y&#39;,u,u&#39;);
          atom u &#9839; (v,i,y,y&#39;,u&#39;); atom u&#39; &#9839; (v,i,y,y&#39;)&#10215; &#10233;
    AbstAtomicP v i y y&#39; =
         Ex t (Ex u (Ex t&#39; (Ex u&#39;
           (AbstTermP v i (Var t) (Var t&#39;) AND AbstTermP v i (Var u) (Var u&#39;) AND
                      ((y EQ Q_Eq (Var t) (Var u) AND y&#39; EQ Q_Eq (Var t&#39;) (Var u&#39;)) OR
                       (y EQ Q_Mem (Var t) (Var u) AND y&#39; EQ Q_Mem (Var t&#39;) (Var u&#39;)))))))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>AbstAtomicP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>AbstAtomicP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; AbstAtomicP v i y y&#39; &#10231; a &#9839; v &#8743; a &#9839; i &#8743; a &#9839; y &#8743; a &#9839; y&#39;&quot;</span></span></span><span>         </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>AbstAtomicP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (AbstAtomicP v i y y&#39;)&quot;</span></span></span><span>              </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thsf</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>u</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t&#39;</span><span class="delimiter">::</span><span>name</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>u&#39;</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom t &#9839; (v,i,y,y&#39;,t&#39;,u,u&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom t&#39; &#9839; (v,i,y,y&#39;,u,u&#39;)&quot;</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;atom u &#9839; (v,i,y,y&#39;,u&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom u&#39; &#9839; (v,i,y,y&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thsf</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>AbstAtomicP_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;(AbstAtomicP v tm y y&#39;)(i::=w) = AbstAtomicP (subst i w v) (subst i w tm) (subst i w y) (subst i w y&#39;)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>u</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t&#39;</span><span class="delimiter">::</span><span>name</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>u&#39;</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom t &#9839; (v,tm,y,y&#39;,w,i,t&#39;,u,u&#39;)&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;atom t&#39; &#9839; (v,tm,y,y&#39;,w,i,u,u&#39;)&quot;</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;atom u &#9839; (v,tm,y,y&#39;,w,i,u&#39;)&quot;</span></span></span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;atom u&#39; &#9839; (v,tm,y,y&#39;,w,i)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>AbstAtomicP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>t</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>t&#39;</span><span> </span><span>u</span><span> </span><span>u&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>AbstAtomicP.simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*The predicate @{text AbsMakeForm}*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>SeqAbstFormP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; tm &#8658; tm &#8658; tm &#8658; tm &#8658; tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom l &#9839; (s,k,v,sli,sl,sl&#39;,m,n,smi,sm,sm&#39;,sni,sn,sn&#39;);
          atom sli &#9839; (s,v,sl,sl&#39;,m,n,smi,sm,sm&#39;,sni,sn,sn&#39;);
          atom sl &#9839; (s,v,sl&#39;,m,n,smi,sm,sm&#39;,sni,sn,sn&#39;);
          atom sl&#39; &#9839; (s,v,m,n,smi,sm,sm&#39;,sni,sn,sn&#39;);
          atom m &#9839; (s,n,smi,sm,sm&#39;,sni,sn,sn&#39;);
          atom n &#9839; (s,smi,sm,sm&#39;,sni,sn,sn&#39;); atom smi &#9839; (s,sm,sm&#39;,sni,sn,sn&#39;);
          atom sm &#9839; (s,sm&#39;,sni,sn,sn&#39;); atom sm&#39; &#9839; (s,sni,sn,sn&#39;);
          atom sni &#9839; (s,sn,sn&#39;); atom sn &#9839; (s,sn&#39;); atom sn&#39; &#9839; (s)&#10215; &#10233;
    SeqAbstFormP v i x x&#39; s k =
      LstSeqP s k (HPair i (HPair x x&#39;)) AND
      All2 l (SUCC k) (Ex sli (Ex sl (Ex sl&#39; (HPair (Var l) (HPair (Var sli) (HPair (Var sl) (Var sl&#39;))) IN s AND
                (AbstAtomicP v (Var sli) (Var sl) (Var sl&#39;) OR
                OrdP (Var sli) AND
                Ex m (Ex n (Ex smi (Ex sm (Ex sm&#39; (Ex sni (Ex sn (Ex sn&#39;
                      (Var m IN Var l AND Var n IN Var l AND
                       HPair (Var m) (HPair (Var smi) (HPair (Var sm) (Var sm&#39;))) IN s AND
                       HPair (Var n) (HPair (Var sni) (HPair (Var sn) (Var sn&#39;))) IN s AND
                       ((Var sli EQ Var smi AND Var sli EQ Var sni AND
                         Var sl EQ Q_Disj (Var sm) (Var sn) AND
                         Var sl&#39; EQ Q_Disj (Var sm&#39;) (Var sn&#39;)) OR
                        (Var sli EQ Var smi AND
                         Var sl EQ Q_Neg (Var sm) AND Var sl&#39; EQ Q_Neg (Var sm&#39;)) OR
                        (SUCC (Var sli) EQ Var smi AND
                         Var sl EQ Q_Ex (Var sm) AND Var sl&#39; EQ Q_Ex (Var sm&#39;))))))))))))))))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>SeqAbstFormP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>SeqAbstFormP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; SeqAbstFormP v i x x&#39; s k &#10231; a &#9839; v &#8743; a &#9839; i &#8743; a &#9839; x &#8743; a &#9839; x&#39; &#8743; a &#9839; s &#8743; a &#9839; k&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SeqAbstFormP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (SeqAbstFormP v i x x&#39; s k)&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thsf</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SeqAbstFormP_imp_OrdP</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;{ SeqAbstFormP v u x x&#39; s k } &#8866; OrdP k&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thOrd</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SeqAbstFormP_imp_LstSeqP</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;{ SeqAbstFormP v u x x&#39; s k } &#8866; LstSeqP s k (HPair u (HPair x x&#39;))&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thLstSeq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sli</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl&#39;</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>smi</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sm</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sm&#39;</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sni</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sn</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sn&#39;</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>atoms</span><span class="delimiter">:</span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom l &#9839; (s,k,v,sli,sl,sl&#39;,m,n,smi,sm,sm&#39;,sni,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sli &#9839; (s,v,sl,sl&#39;,m,n,smi,sm,sm&#39;,sni,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sl &#9839; (s,v,sl&#39;,m,n,smi,sm,sm&#39;,sni,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sl&#39; &#9839; (s,v,m,n,smi,sm,sm&#39;,sni,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom m &#9839; (s,n,smi,sm,sm&#39;,sni,sn,sn&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom n &#9839; (s,smi,sm,sm&#39;,sni,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom smi &#9839; (s,sm,sm&#39;,sni,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sm &#9839; (s,sm&#39;,sni,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sm&#39; &#9839; (s,sni,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sni &#9839; (s,sn,sn&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom sn &#9839; (s,sn&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom sn&#39; &#9839; s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thsf</span><span> </span><span class="var">?thOrd</span><span> </span><span class="var">?thLstSeq</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>LstSeqP_OrdP</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SeqAbstFormP_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;(SeqAbstFormP v u x x&#39; s k)(i::=t) =
       SeqAbstFormP (subst i t v) (subst i t u) (subst i t x) (subst i t x&#39;) (subst i t s) (subst i t k)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sli</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl&#39;</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>smi</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sm</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sm&#39;</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sni</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sn</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sn&#39;</span><span class="delimiter">::</span><span>name</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom l &#9839; (i,t,s,k,v,sli,sl,sl&#39;,m,n,smi,sm,sm&#39;,sni,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sli &#9839; (i,t,s,v,sl,sl&#39;,m,n,smi,sm,sm&#39;,sni,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sl &#9839; (i,t,s,v,sl&#39;,m,n,smi,sm,sm&#39;,sni,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sl&#39; &#9839; (i,t,s,v,m,n,smi,sm,sm&#39;,sni,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom m &#9839; (i,t,s,n,smi,sm,sm&#39;,sni,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom n &#9839; (i,t,s,smi,sm,sm&#39;,sni,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom smi &#9839; (i,t,s,sm,sm&#39;,sni,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sm &#9839; (i,t,s,sm&#39;,sni,sn,sn&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom sm&#39; &#9839; (i,t,s,sni,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sni &#9839; (i,t,s,sn,sn&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom sn &#9839; (i,t,s,sn&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom sn&#39; &#9839; (i,t,s)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>SeqAbstFormP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>l</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>sli</span><span> </span><span>sl</span><span> </span><span>sl&#39;</span><span> </span><span>m</span><span> </span><span>n</span><span> </span><span>smi</span><span> </span><span>sm</span><span> </span><span>sm&#39;</span><span> </span><span>sni</span><span> </span><span>sn</span><span> </span><span>sn&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>SeqAbstFormP.simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*Defining the syntax: the main AbstForm predicate*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>AbstFormP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; tm &#8658; tm &#8658; tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom s &#9839; (v,i,x,x&#39;,k);
          atom k &#9839; (v,i,x,x&#39;)&#10215; &#10233;
    AbstFormP v i x x&#39; = VarP v AND OrdP i AND Ex s (Ex k (SeqAbstFormP v i x x&#39; (Var s) (Var k)))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>AbstFormP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>AbstFormP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; AbstFormP v i x x&#39; &#10231; a &#9839; v &#8743; a &#9839; i &#8743; a &#9839; x &#8743; a &#9839; x&#39;&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>AbstFormP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (AbstFormP v i x x&#39;)&quot;</span></span></span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thsf</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>k</span><span class="delimiter">::</span><span>name</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom s &#9839; (v,i,x,x&#39;,k)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom k &#9839; (v,i,x,x&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thsf</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>AbstFormP_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;(AbstFormP v i x x&#39;)(j::=t) = AbstFormP (subst j t v) (subst j t i) (subst j t x) (subst j t x&#39;)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>k</span><span class="delimiter">::</span><span>name</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom s &#9839; (v,i,x,x&#39;,t,j,k)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom k &#9839; (v,i,x,x&#39;,t,j)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>AbstFormP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>k</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>AbstFormP.simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*Substitution over formulas*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*The predicate @{text SubstAtomicP}*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>SubstAtomicP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; tm &#8658; tm &#8658; tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom t &#9839; (v,tm,y,y&#39;,t&#39;,u,u&#39;);
          atom t&#39; &#9839; (v,tm,y,y&#39;,u,u&#39;);
          atom u &#9839; (v,tm,y,y&#39;,u&#39;);
          atom u&#39; &#9839; (v,tm,y,y&#39;)&#10215; &#10233;
    SubstAtomicP v tm y y&#39; =
         Ex t (Ex u (Ex t&#39; (Ex u&#39;
           (SubstTermP v tm (Var t) (Var t&#39;) AND SubstTermP v tm (Var u) (Var u&#39;) AND
                      ((y EQ Q_Eq (Var t) (Var u) AND y&#39; EQ Q_Eq (Var t&#39;) (Var u&#39;)) OR
                       (y EQ Q_Mem (Var t) (Var u) AND y&#39; EQ Q_Mem (Var t&#39;) (Var u&#39;)))))))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>SubstAtomicP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>SubstAtomicP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; SubstAtomicP v tm y y&#39; &#10231; a &#9839; v &#8743; a &#9839; tm &#8743; a &#9839; y &#8743; a &#9839; y&#39;&quot;</span></span></span><span>           </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SubstAtomicP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (SubstAtomicP v tm y y&#39;)&quot;</span></span></span><span>               </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thsf</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>u</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t&#39;</span><span class="delimiter">::</span><span>name</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>u&#39;</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom t &#9839; (v,tm,y,y&#39;,t&#39;,u,u&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom t&#39; &#9839; (v,tm,y,y&#39;,u,u&#39;)&quot;</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;atom u &#9839; (v,tm,y,y&#39;,u&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom u&#39; &#9839; (v,tm,y,y&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thsf</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SubstAtomicP_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(SubstAtomicP v tm y y&#39;)(i::=w) = SubstAtomicP (subst i w v) (subst i w tm) (subst i w y) (subst i w y&#39;)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>u</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t&#39;</span><span class="delimiter">::</span><span>name</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>u&#39;</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom t &#9839; (v,tm,y,y&#39;,w,i,t&#39;,u,u&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom t&#39; &#9839; (v,tm,y,y&#39;,w,i,u,u&#39;)&quot;</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;atom u &#9839; (v,tm,y,y&#39;,w,i,u&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom u&#39; &#9839; (v,tm,y,y&#39;,w,i)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>SubstAtomicP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>t</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>t&#39;</span><span> </span><span>u</span><span> </span><span>u&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SubstAtomicP_cong</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;H &#8866; v EQ v&#39;; H &#8866; tm EQ tm&#39;; H &#8866; x EQ x&#39;; H &#8866; y EQ y&#39;&#10215;
   &#10233; H &#8866; SubstAtomicP v tm x y IFF SubstAtomicP v&#39; tm&#39; x&#39; y&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>P4_cong</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*The predicate @{text SubstMakeForm}*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>SeqSubstFormP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; tm &#8658; tm &#8658; tm &#8658; tm &#8658; tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom l &#9839; (s,k,v,u,sl,sl&#39;,m,n,sm,sm&#39;,sn,sn&#39;);
          atom sl &#9839; (s,v,u,sl&#39;,m,n,sm,sm&#39;,sn,sn&#39;);
          atom sl&#39; &#9839; (s,v,u,m,n,sm,sm&#39;,sn,sn&#39;);
          atom m &#9839; (s,n,sm,sm&#39;,sn,sn&#39;); atom n &#9839; (s,sm,sm&#39;,sn,sn&#39;);
          atom sm &#9839; (s,sm&#39;,sn,sn&#39;); atom sm&#39; &#9839; (s,sn,sn&#39;);
          atom sn &#9839; (s,sn&#39;); atom sn&#39; &#9839; s&#10215; &#10233;
    SeqSubstFormP v u x x&#39; s k =
      LstSeqP s k (HPair x x&#39;) AND
      All2 l (SUCC k) (Ex sl (Ex sl&#39; (HPair (Var l) (HPair (Var sl) (Var sl&#39;)) IN s AND
                (SubstAtomicP v u (Var sl) (Var sl&#39;) OR
                Ex m (Ex n (Ex sm (Ex sm&#39; (Ex sn (Ex sn&#39; (Var m IN Var l AND Var n IN Var l AND
                       HPair (Var m) (HPair (Var sm) (Var sm&#39;)) IN s AND
                       HPair (Var n) (HPair (Var sn) (Var sn&#39;)) IN s AND
                       ((Var sl EQ Q_Disj (Var sm) (Var sn) AND
                        Var sl&#39; EQ Q_Disj (Var sm&#39;) (Var sn&#39;)) OR
                        (Var sl EQ Q_Neg (Var sm) AND Var sl&#39; EQ Q_Neg (Var sm&#39;)) OR
                        (Var sl EQ Q_Ex (Var sm) AND Var sl&#39; EQ Q_Ex (Var sm&#39;)))))))))))))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>SeqSubstFormP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>SeqSubstFormP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; SeqSubstFormP v u x x&#39; s k &#10231; a &#9839; v &#8743; a &#9839; u &#8743; a &#9839; x &#8743; a &#9839; x&#39; &#8743; a &#9839; s &#8743; a &#9839; k&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SeqSubstFormP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (SeqSubstFormP v u x x&#39; s k)&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thsf</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SeqSubstFormP_imp_OrdP</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;{ SeqSubstFormP v u x x&#39; s k } &#8866; OrdP k&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thOrd</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SeqSubstFormP_imp_LstSeqP</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;{ SeqSubstFormP v u x x&#39; s k } &#8866; LstSeqP s k (HPair x x&#39;)&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thLstSeq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl&#39;</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>sm</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sm&#39;</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sn</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sn&#39;</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>atoms</span><span class="delimiter">:</span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom l &#9839; (s,k,v,u,sl,sl&#39;,m,n,sm,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sl &#9839; (s,v,u,sl&#39;,m,n,sm,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sl&#39; &#9839; (s,v,u,m,n,sm,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom m &#9839; (s,n,sm,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom n &#9839; (s,sm,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sm &#9839; (s,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom sm&#39; &#9839; (s,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sn &#9839; (s,sn&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom sn&#39; &#9839; (s)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thsf</span><span> </span><span class="var">?thOrd</span><span> </span><span class="var">?thLstSeq</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>LstSeqP_OrdP</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SeqSubstFormP_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;(SeqSubstFormP v u x x&#39; s k)(i::=t) =
       SeqSubstFormP (subst i t v) (subst i t u) (subst i t x) (subst i t x&#39;) (subst i t s) (subst i t k)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl&#39;</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>sm</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sm&#39;</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sn</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sn&#39;</span><span class="delimiter">::</span><span>name</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom l &#9839; (s,k,v,u,t,i,sl,sl&#39;,m,n,sm,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sl &#9839; (s,v,u,t,i,sl&#39;,m,n,sm,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sl&#39; &#9839; (s,v,u,t,i,m,n,sm,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom m &#9839; (s,t,i,n,sm,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom n &#9839; (s,t,i,sm,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sm &#9839; (s,t,i,sm&#39;,sn,sn&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom sm&#39; &#9839; (s,t,i,sn,sn&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;atom sn &#9839; (s,t,i,sn&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom sn&#39; &#9839; (s,t,i)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>SeqSubstFormP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>l</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>sl</span><span> </span><span>sl&#39;</span><span> </span><span>m</span><span> </span><span>n</span><span> </span><span>sm</span><span> </span><span>sm&#39;</span><span> </span><span>sn</span><span> </span><span>sn&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SeqSubstFormP_cong</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;H &#8866; t EQ t&#39;; H &#8866; u EQ u&#39;; H &#8866; s EQ s&#39;; H &#8866; k EQ k&#39;&#10215;
   &#10233; H &#8866; SeqSubstFormP v i t u s k IFF SeqSubstFormP v i t&#39; u&#39; s&#39; k&#39;&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>P4_cong</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>tms</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;[v,i]&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fresh_Cons</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>SeqSubstFormP.simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*Defining the syntax: the main SubstForm predicate*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>SubstFormP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; tm &#8658; tm &#8658; tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom s &#9839; (v,i,x,x&#39;,k); atom k &#9839; (v,i,x,x&#39;)&#10215; &#10233;
    SubstFormP v i x x&#39; =
      VarP v AND TermP i AND Ex s (Ex k (SeqSubstFormP v i x x&#39; (Var s) (Var k)))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>SubstFormP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>SubstFormP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; SubstFormP v i x x&#39; &#10231; a &#9839; v &#8743; a &#9839; i &#8743; a &#9839; x &#8743; a &#9839; x&#39;&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SubstFormP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (SubstFormP v i x x&#39;)&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thsf</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>k</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom s &#9839; (v,i,x,x&#39;,k)&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;atom k &#9839; (v,i,x,x&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thsf</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SubstFormP_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;(SubstFormP v i x x&#39;)(j::=t) = SubstFormP (subst j t v) (subst j t i) (subst j t x) (subst j t x&#39;)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>k</span><span class="delimiter">::</span><span>name</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom s &#9839; (v,i,x,x&#39;,t,j,k)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom k &#9839; (v,i,x,x&#39;,t,j)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>SubstFormP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>k</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SubstFormP_cong</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;H &#8866; v EQ v&#39;; H &#8866; i EQ i&#39;; H &#8866; t EQ t&#39;; H &#8866; u EQ u&#39;&#10215;
   &#10233; H &#8866; SubstFormP v i t u IFF SubstFormP v&#39; i&#39; t&#39; u&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>P4_cong</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ground_SubstFormP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ground_fm (SubstFormP v y x x&#39;) &#10231; ground v &#8743; ground y &#8743; ground x &#8743; ground x&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ground_aux_def</span><span> </span><span>ground_fm_aux_def</span><span> </span><span>supp_conv_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>SubstFormP.simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*The predicate @{text AtomicP}*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>AtomicP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom t &#9839; (u,y); atom u &#9839; y&#10215; &#10233;
    AtomicP y = Ex t (Ex u (TermP (Var t) AND TermP (Var u) AND
                      (y EQ Q_Eq (Var t) (Var u) OR
                       y EQ Q_Mem (Var t) (Var u))))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>AtomicP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>AtomicP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; AtomicP y &#10231; a &#9839; y&quot;</span></span></span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>AtomicP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (AtomicP y)&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thsf</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>u</span><span class="delimiter">::</span><span>name</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom t &#9839; (u,y)&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;atom u &#9839; y&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thsf</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>AtompicP_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(AtomicP t)(j::=w) = AtomicP (subst j w t)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="delimiter">::</span><span> </span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom x &#9839; (j,w,t,y)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom y &#9839; (j,w,t)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>AtomicP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*The predicate @{text MakeForm} *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>MakeFormP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; tm &#8658; tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom v &#9839; (y,u,w,au); atom au &#9839; (y,u,w)&#10215; &#10233;
    MakeFormP y u w =
      y EQ Q_Disj u w OR y EQ Q_Neg u OR
      Ex v (Ex au (AbstFormP (Var v) Zero u (Var au) AND y EQ Q_Ex (Var au)))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>MakeFormP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>MakeFormP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; MakeFormP y u w &#10231; a &#9839; y &#8743; a &#9839; u &#8743; a &#9839; w&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>MakeFormP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (MakeFormP y u w)&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thsf</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>v</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>au</span><span class="delimiter">::</span><span>name</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom v &#9839; (y,u,w,au)&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;atom au &#9839; (y,u,w)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thsf</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>MakeFormP.simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>MakeFormP_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(MakeFormP y u t)(j::=w) = MakeFormP (subst j w y) (subst j w u) (subst j w t)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="delimiter">::</span><span> </span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom a &#9839; (j,w,y,u,t,b)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom b &#9839; (j,w,y,u,t)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>MakeFormP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>a</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>b</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*The predicate @{text SeqFormP} *}</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*SeqForm(s,k,t) &#8801; LstSeq(s,k,t) &#8743; (&#8704;n&#8712;k)[Atomic (s n) &#8744; (&#8707;m,l&#8712;n)[MakeForm (s m) (s l) (s n)]]*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>SeqFormP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; tm &#8658; tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom l &#9839; (s,k,t,sl,m,n,sm,sn); atom sl &#9839; (s,k,t,m,n,sm,sn);
          atom m &#9839; (s,k,t,n,sm,sn); atom n &#9839; (s,k,t,sm,sn);
          atom sm &#9839; (s,k,t,sn); atom sn &#9839; (s,k,t)&#10215; &#10233;
    SeqFormP s k t =
      LstSeqP s k t AND
      All2 n (SUCC k) (Ex sn (HPair (Var n) (Var sn) IN s AND (AtomicP (Var sn) OR
                Ex m (Ex l (Ex sm (Ex sl (Var m IN Var n AND Var l IN Var n AND
                       HPair (Var m) (Var sm) IN s AND HPair (Var l) (Var sl) IN s AND
                       MakeFormP (Var sn) (Var sm) (Var sl))))))))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>SeqFormP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>SeqFormP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; SeqFormP s k t &#10231; a &#9839; s &#8743; a &#9839; k &#8743; a &#9839; t&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SeqFormP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (SeqFormP s k t)&quot;</span></span></span><span>          </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thsf</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SeqFormP_imp_OrdP</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;{ SeqFormP s k t } &#8866; OrdP k&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thOrd</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SeqFormP_imp_LstSeqP</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;{ SeqFormP s k t } &#8866; LstSeqP s k t&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thLstSeq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sm</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sn</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>atoms</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom l &#9839; (s,k,t,sl,m,n,sm,sn)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom sl &#9839; (s,k,t,m,n,sm,sn)&quot;</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;atom m &#9839; (s,k,t,n,sm,sn)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom n &#9839; (s,k,t,sm,sn)&quot;</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;atom sm &#9839; (s,k,t,sn)&quot;</span></span></span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;atom sn &#9839; (s,k,t)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thsf</span><span> </span><span class="var">?thOrd</span><span> </span><span class="var">?thLstSeq</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>LstSeqP_OrdP</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SeqFormP_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;(SeqFormP s k t)(j::=w) = SeqFormP (subst j w s) (subst j w k) (subst j w t)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sm</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sn</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom l &#9839; (j,w,s,t,k,sl,m,n,sm,sn)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom sl &#9839; (j,w,s,k,t,m,n,sm,sn)&quot;</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;atom m &#9839; (j,w,s,k,t,n,sm,sn)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom n &#9839; (j,w,s,k,t,sm,sn)&quot;</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;atom sm &#9839; (j,w,s,k,t,sn)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom sn &#9839; (j,w,s,k,t)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>SeqFormP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>l</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>sl</span><span> </span><span>m</span><span> </span><span>n</span><span> </span><span>sm</span><span> </span><span>sn</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*The predicate @{text FormP}*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*Definition*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>FormP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom k &#9839; (s,y); atom s &#9839; y&#10215; &#10233;
    FormP y = Ex k (Ex s (SeqFormP (Var s) (Var k) y))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>FormP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>FormP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; FormP y &#10231; a &#9839; y&quot;</span></span></span><span>              </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>FormP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (FormP y)&quot;</span></span></span><span>                 </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thsf</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>k</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span class="delimiter">::</span><span>name</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>k</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom k &#9839; (s,y)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom s &#9839; y&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thsf</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FormP_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(FormP y)(j::=w) = FormP (subst j w y)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>k</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom k &#9839; (s,j,w,y)&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;atom s &#9839; (j,w,y)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>FormP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>k</span><span> </span><span>s</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*The predicate @{text VarNonOccFormP} (Derived from @{text SubstFormP})*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>VarNonOccFormP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;VarNonOccFormP v x = FormP x AND SubstFormP v Zero x x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>VarNonOccFormP_graph_aux_def</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>VarNonOccFormP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; VarNonOccFormP v y &#10231; a &#9839; v &#8743; a &#9839; y&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VarNonOccFormP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (VarNonOccFormP v y)&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thsf</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thsf</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>VarNonOccFormP.simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span></pre>

</div>
</body>
</html>
