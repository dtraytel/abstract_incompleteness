<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Pf_Predicates (Isabelle2020-RC3: March 2020)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Pf_Predicates</h1>

<span class="command">theory</span> <span class="name">Pf_Predicates</span><br/>
<span class="keyword">imports</span> <a href="Coding_Predicates.html"><span class="name">Coding_Predicates</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">chapter</span></span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*Formalizing Provability*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Pf_Predicates</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Coding_Predicates</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Section 4 Predicates (Leading up to Pf)*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*The predicate @{text SentP}, for the Sentiential (Boolean) Axioms*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>SentP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom y &#9839; (z,w,x); atom z &#9839; (w,x); atom w &#9839; x&#10215; &#10233;
    SentP x = Ex y (Ex z (Ex w (FormP (Var y) AND FormP (Var z) AND FormP (Var w) AND
               ( (x EQ Q_Imp (Var y) (Var y)) OR
                 (x EQ Q_Imp (Var y) (Q_Disj (Var y) (Var z)) OR
                 (x EQ Q_Imp (Q_Disj (Var y) (Var y)) (Var y)) OR
                 (x EQ Q_Imp (Q_Disj (Var y) (Q_Disj (Var z) (Var w))) 
                             (Q_Disj (Q_Disj (Var y) (Var z)) (Var w))) OR
                 (x EQ Q_Imp (Q_Disj (Var y) (Var z))
                             (Q_Imp (Q_Disj (Q_Neg (Var y)) (Var w)) (Q_Disj (Var z) (Var w)))))))))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>SentP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>SentP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; SentP x &#10231; a &#9839; x&quot;</span></span></span><span>                  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SentP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (SentP x)&quot;</span></span></span><span>                     </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thsf</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>y</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>z</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>w</span><span class="delimiter">::</span><span>name</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom y &#9839; (z,w,x)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom z &#9839; (w,x)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom w &#9839; x&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thsf</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*The predicate @{text Equality_axP}, for the Equality Axioms*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">function</span></span><span> </span><span>Equality_axP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Equality_axP x =
    x EQ &#8968;refl_ax&#8969; OR x EQ &#8968;eq_cong_ax&#8969; OR x EQ &#8968;mem_cong_ax&#8969; OR x EQ &#8968;eats_cong_ax&#8969;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">termination</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*The predicate @{text HF_axP}, for the HF Axioms*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">function</span></span><span> </span><span>HF_axP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;HF_axP x = x EQ &#8968;HF1&#8969; OR x EQ &#8968;HF2&#8969;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">termination</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HF_axP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (HF_axP t)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*The specialisation axioms*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*Defining the syntax*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>Special_axP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; fm&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom v &#9839; (p,sx,y,ax,x); atom x &#9839; (p,sx,y,ax);
    atom ax &#9839; (p,sx,y); atom y &#9839; (p,sx); atom sx &#9839; p&#10215; &#10233;
  Special_axP p = Ex v (Ex x (Ex ax (Ex y (Ex sx
                   (FormP (Var x) AND VarP (Var v) AND TermP (Var y) AND
                    AbstFormP (Var v) Zero (Var x) (Var ax) AND
                    SubstFormP (Var v) (Var y) (Var x) (Var sx) AND
                    p EQ Q_Imp (Var sx) (Q_Ex (Var ax)))))))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>Special_axP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>Special_axP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; Special_axP p &#10231; a &#9839; p&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Special_axP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (Special_axP p)&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis3</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>v</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ax</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sx</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom v &#9839; (p,sx,y,ax,x)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom x &#9839; (p,sx,y,ax)&quot;</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;atom ax &#9839; (p,sx,y)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom y &#9839; (p,sx)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom sx &#9839; p&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thesis3</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*The induction axioms*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*Defining the syntax*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>Induction_axP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; fm&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom ax &#9839; (p,v,w,x,x0,xw,xevw,allw,allvw);
    atom allvw &#9839; (p,v,w,x,x0,xw,xevw,allw); atom allw &#9839; (p,v,w,x,x0,xw,xevw);
    atom xevw &#9839; (p,v,w,x,x0,xw); atom xw &#9839; (p,v,w,x,x0);
    atom x0 &#9839; (p,v,w,x); atom x &#9839; (p,v,w);
    atom w &#9839; (p,v); atom v &#9839; p&#10215; &#10233;
  Induction_axP p = Ex v (Ex w (Ex x (Ex x0 (Ex xw (Ex xevw (Ex allw (Ex allvw (Ex ax
               ((Var v NEQ Var w) AND VarNonOccFormP (Var w) (Var x) AND
                SubstFormP (Var v) Zero (Var x) (Var x0) AND
                SubstFormP (Var v) (Var w) (Var x) (Var xw) AND
                SubstFormP (Var v) (Q_Eats (Var v) (Var w)) (Var x) (Var xevw) AND
                AbstFormP (Var w) Zero (Q_Imp (Var x) (Q_Imp (Var xw) (Var xevw))) (Var allw) AND
                AbstFormP (Var v) Zero (Q_All (Var allw)) (Var allvw) AND
                AbstFormP (Var v) Zero (Var x) (Var ax) AND
                p EQ Q_Imp (Var x0) (Q_Imp (Q_All (Var allvw)) (Q_All (Var ax))))))))))))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>Induction_axP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>Induction_axP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; Induction_axP p &#10231; a &#9839; p&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Induction_axP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (Induction_axP p)&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis3</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>v</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>w</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x0</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xw</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xevw</span><span class="delimiter">::</span><span>name</span><span>
</span><span>                 </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>allw</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>allvw</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ax</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>atoms</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom ax &#9839; (p,v,w,x,x0,xw,xevw,allw,allvw)&quot;</span></span></span><span>
</span><span>                 </span><span class="string"><span class="delete"><span class="delete">&quot;atom allvw &#9839; (p,v,w,x,x0,xw,xevw,allw)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom allw &#9839; (p,v,w,x,x0,xw,xevw)&quot;</span></span></span><span>
</span><span>                 </span><span class="string"><span class="delete"><span class="delete">&quot;atom xevw &#9839; (p,v,w,x,x0,xw)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom xw &#9839; (p,v,w,x,x0)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom x0 &#9839; (p,v,w,x)&quot;</span></span></span><span>
</span><span>                 </span><span class="string"><span class="delete"><span class="delete">&quot;atom x &#9839; (p,v,w)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom w &#9839; (p,v)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom v &#9839; p&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thesis3</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*The predicate @{text AxiomP}, for any Axioms*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>AxiomP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;AxiomP x &#8801; x EQ &#8968;extra_axiom&#8969; OR SentP x OR Equality_axP x OR
                    HF_axP x OR Special_axP x OR Induction_axP x&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>AxiomP_I</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;{} &#8866; AxiomP &#8968;extra_axiom&#8969;&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;{} &#8866; SentP x &#10233; {} &#8866; AxiomP x&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;{} &#8866; Equality_axP x &#10233; {} &#8866; AxiomP x&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;{} &#8866; HF_axP x &#10233; {} &#8866; AxiomP x&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;{} &#8866; Special_axP x &#10233; {} &#8866; AxiomP x&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;{} &#8866; Induction_axP x &#10233; {} &#8866; AxiomP x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>AxiomP_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Disj_I1</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>Refl</span><span class="delimiter">,</span><span>
</span><span>      </span><span>rule</span><span> </span><span>Disj_I2</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>Disj_I1</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">,</span><span>
</span><span>      </span><span>rule</span><span> </span><span>Disj_I2</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>Disj_I2</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>Disj_I1</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">,</span><span>
</span><span>      </span><span>rule</span><span> </span><span>Disj_I2</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>Disj_I2</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>Disj_I2</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>Disj_I1</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">,</span><span>
</span><span>      </span><span>rule</span><span> </span><span>Disj_I2</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>Disj_I2</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>Disj_I2</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>Disj_I2</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>Disj_I1</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">,</span><span>
</span><span>      </span><span>rule</span><span> </span><span>Disj_I2</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>Disj_I2</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>Disj_I2</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>Disj_I2</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>Disj_I2</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>AxiomP_eqvt</span><span> </span><span class="delimiter">[</span><span>eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(p &#8729; AxiomP x) = AxiomP (p &#8729; x)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>AxiomP_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>AxiomP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; AxiomP x &#10231; a &#9839; x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>AxiomP_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>AxiomP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (AxiomP t)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>AxiomP_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*The predicate @{text ModPonP}, for the inference rule Modus Ponens*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ModPonP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; tm &#8658; tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ModPonP x y z = (y EQ Q_Imp x z)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ModPonP_eqvt</span><span> </span><span class="delimiter">[</span><span>eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(p &#8729; ModPonP x y z) = ModPonP (p &#8729; x) (p &#8729; y) (p &#8729; z)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ModPonP_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ModPonP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; ModPonP x y z &#10231; a &#9839; x &#8743; a &#9839; y &#8743; a &#9839; z&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ModPonP_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ModPonP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (ModPonP t u v)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ModPonP_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ModPonP_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(ModPonP t u v)(i::=w) = ModPonP (subst i w t) (subst i w u) (subst i w v)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ModPonP_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*The predicate @{text ExistsP}, for the existential rule *}</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*Definition*}</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  &quot;&#8866; A IMP B &#10233; atom i &#9839; B &#10233;  &#8866; (Ex i A) IMP B&quot; *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>ExistsP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; tm &#8658; fm&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom x &#9839; (p,q,v,y,x&#39;); atom x&#39; &#9839; (p,q,v,y);
    atom y &#9839; (p,q,v); atom v &#9839; (p,q)&#10215; &#10233;
  ExistsP p q = Ex x (Ex x&#39; (Ex y (Ex v (FormP (Var x) AND
                    VarNonOccFormP (Var v) (Var y) AND
                    AbstFormP (Var v) Zero (Var x) (Var x&#39;) AND
                    p EQ Q_Imp (Var x) (Var y) AND
                    q EQ Q_Imp (Q_Ex (Var x&#39;)) (Var y)))))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>ExistsP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>ExistsP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; ExistsP p q &#10231; a &#9839; p &#8743; a &#9839; q&quot;</span></span></span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ExistsP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (ExistsP p q)&quot;</span></span></span><span>   </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis3</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x&#39;</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>v</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom x &#9839; (p,q,v,y,x&#39;)&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;atom x&#39; &#9839; (p,q,v,y)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom y &#9839; (p,q,v)&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;atom v &#9839; (p,q)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thesis3</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ExistsP_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(ExistsP p q)(j::=w) = ExistsP (subst j w p) (subst j w q)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x&#39;</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>v</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom x &#9839; (j,w,p,q,v,y,x&#39;)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom x&#39; &#9839; (j,w,p,q,v,y)&quot;</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;atom y &#9839; (j,w,p,q,v)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom v &#9839; (j,w,p,q)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ExistsP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>x&#39;</span><span> </span><span>y</span><span> </span><span>v</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*The predicate @{text SubstP}, for the substitution rule *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*Although the substitution rule is derivable in the calculus, the derivation is
too complicated to reproduce within the proof function. It is much easier to
provide it as an immediate inference step, justifying its soundness in terms
of other inference rules.*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*Definition*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>SubstP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; tm &#8658; fm&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom u &#9839; (p,q,v); atom v &#9839; (p,q)&#10215; &#10233;
   SubstP p q = Ex v (Ex u (SubstFormP (Var v) (Var u) p q))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>SubstP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>SubstP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; SubstP p q &#10231; a &#9839; p &#8743; a &#9839; q&quot;</span></span></span><span>        </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SubstP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (SubstP p q)&quot;</span></span></span><span>                           </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis3</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>u</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>v</span><span class="delimiter">::</span><span>name</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom u &#9839; (p,q,v)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom v &#9839; (p,q)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thesis3</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SubstP_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(SubstP p q)(j::=w) = SubstP (subst j w p) (subst j w q)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>u</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>v</span><span class="delimiter">::</span><span>name</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom u &#9839; (j,w,p,q,v)&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;atom v &#9839; (j,w,p,q)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>SubstP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>u</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>v</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*The predicate @{text PrfP}*}</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Prf(s,k,t) &#8801; LstSeq(s,k,t) &#8743; (&#8704;n&#8712;k)[Sent (s n) &#8744; (&#8707;m,l&#8712;n)[ModPon (s m) (s l) (s n)]]*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>PrfP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; tm &#8658; tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom l &#9839; (s,sl,m,n,sm,sn); atom sl &#9839; (s,m,n,sm,sn);
          atom m &#9839; (s,n,sm,sn); atom n &#9839; (s,k,sm,sn);
          atom sm &#9839; (s,sn); atom sn &#9839; (s)&#10215; &#10233;
    PrfP s k t =
      LstSeqP s k t AND
      All2 n (SUCC k) (Ex sn (HPair (Var n) (Var sn) IN s AND (AxiomP (Var sn) OR
                Ex m (Ex l (Ex sm (Ex sl (Var m IN Var n AND Var l IN Var n AND
                       HPair (Var m) (Var sm) IN s AND HPair (Var l) (Var sl) IN s AND
                       (ModPonP (Var sm) (Var sl) (Var sn) OR
                        ExistsP (Var sm) (Var sn) OR
                        SubstP (Var sm) (Var sn)))))))))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>PrfP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>PrfP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; PrfP s k t &#10231; a &#9839; s &#8743; a &#9839; k &#8743; a &#9839; t&quot;</span></span></span><span>      </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>PrfP_imp_OrdP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;{PrfP s k t} &#8866; OrdP k&quot;</span></span></span><span>         </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thord</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>PrfP_imp_LstSeqP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{PrfP s k t} &#8866; LstSeqP s k t&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thlstseq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>PrfP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>           </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (PrfP s k t)&quot;</span></span></span><span>         </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thsf</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sm</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sn</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>atoms</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom l &#9839; (s,sl,m,n,sm,sn)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom sl &#9839; (s,m,n,sm,sn)&quot;</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;atom m &#9839; (s,n,sm,sn)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom n &#9839; (s,k,sm,sn)&quot;</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;atom sm &#9839; (s,sn)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom sn &#9839; (s)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thord</span><span> </span><span class="var">?thlstseq</span><span> </span><span class="var">?thsf</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>LstSeqP_OrdP</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>PrfP_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;(PrfP t u v)(j::=w) = PrfP (subst j w t) (subst j w u) (subst j w v)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sm</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sn</span><span class="delimiter">::</span><span>name</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom l &#9839; (t,u,v,j,w,sl,m,n,sm,sn)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom sl &#9839; (t,u,v,j,w,m,n,sm,sn)&quot;</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;atom m &#9839; (t,u,v,j,w,n,sm,sn)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom n &#9839; (t,u,v,j,w,sm,sn)&quot;</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;atom sm &#9839; (t,u,v,j,w,sn)&quot;</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;atom sn &#9839; (t,u,v,j,w)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>PrfP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>l</span><span> </span><span>_</span><span> </span><span>sl</span><span> </span><span>m</span><span> </span><span>n</span><span> </span><span>sm</span><span> </span><span>sn</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*The predicate @{text PfP}*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_function</span></span><span> </span><span>PfP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tm &#8658; fm&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;atom k &#9839; (s,y); atom s &#9839; y&#10215; &#10233;
    PfP y = Ex k (Ex s (PrfP (Var s) (Var k) y))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eqvt_def</span><span> </span><span>PfP_graph_aux_def</span><span> </span><span>flip_fresh_fresh</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_termination</span></span><span> </span><span class="delimiter">(</span><span>eqvt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>PfP_fresh_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#9839; PfP y &#10231; a &#9839; y&quot;</span></span></span><span>           </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>PfP_sf</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Sigma_fm (PfP y)&quot;</span></span></span><span>                      </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thsf</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>k</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom k &#9839; (s,y)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom s &#9839; y&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis1</span><span> </span><span class="var">?thsf</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>PfP_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(PfP t)(j::=w) = PfP (subst j w t)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>k</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom k &#9839; (s,t,j,w)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atom s &#9839; (t,j,w)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>PfP.simps</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>k</span><span> </span><span>s</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ground_PfP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ground_fm (PfP y) = ground y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ground_aux_def</span><span> </span><span>ground_fm_aux_def</span><span> </span><span>supp_conv_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span></pre>

</div>
</body>
</html>
